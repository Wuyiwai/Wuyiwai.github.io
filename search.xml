<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode记录</title>
    <url>/2019/11/12/Algorithm/Leetcode%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">题目</th>
<th align="center">题解</th>
<th align="center">标签</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">13</a></td>
<td align="center"><a href="https://github.com/Wuyiwai/Algorithm/blob/master/13-roman-to-integer.php" target="_blank" rel="noopener">罗马数字转整数</a></td>
<td align="center">Map</td>
</tr>
<tr>
<td align="center"><a href="https://leetcode-cn.com/problems/pascals-triangle/" target="_blank" rel="noopener">118</a></td>
<td align="center"><a href="https://github.com/Wuyiwai/Algorithm/blob/master/118-pascals-triangle.php" target="_blank" rel="noopener">杨辉三角</a></td>
<td align="center">动态规划</td>
</tr>
<tr>
<td align="center"><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136</a></td>
<td align="center"><a href="https://github.com/Wuyiwai/Algorithm/blob/master/136-single-number.php" target="_blank" rel="noopener">只出现一次的数字</a></td>
<td align="center">异或/排序后比较</td>
</tr>
<tr>
<td align="center"><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">169</a></td>
<td align="center"><a href="https://github.com/Wuyiwai/Algorithm/blob/master/169-majority-element.php" target="_blank" rel="noopener">求众数</a></td>
<td align="center">哈希表</td>
</tr>
<tr>
<td align="center"><a href="https://leetcode-cn.com/problems/excel-sheet-column-number/" target="_blank" rel="noopener">171</a></td>
<td align="center"><a href="https://github.com/Wuyiwai/Algorithm/blob/master/171-excel-sheet-column-number.php" target="_blank" rel="noopener">Excel表列序号</a></td>
<td align="center">进制转换</td>
</tr>
<tr>
<td align="center"><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">191</a></td>
<td align="center"><a href="https://github.com/Wuyiwai/Algorithm/blob/master/191-number-of-1-bits.php" target="_blank" rel="noopener">位1的个数</a></td>
<td align="center">位操作</td>
</tr>
<tr>
<td align="center"><a href="https://leetcode-cn.com/problems/majority-element-ii/" target="_blank" rel="noopener">229</a></td>
<td align="center"><a href="https://github.com/Wuyiwai/Algorithm/blob/master/229-majority-element-ii.php" target="_blank" rel="noopener">求众数2</a></td>
<td align="center">哈希表</td>
</tr>
<tr>
<td align="center"><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">344</a></td>
<td align="center"><a href="https://github.com/Wuyiwai/Algorithm/blob/master/344-reverse-string.php" target="_blank" rel="noopener">反转字符串</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center"><a href="https://leetcode-cn.com/problems/fizz-buzz/" target="_blank" rel="noopener">412</a></td>
<td align="center"><a href="https://github.com/Wuyiwai/Algorithm/blob/master/412-fizz-buzz.php" target="_blank" rel="noopener">Fizz Buzz</a></td>
<td align="center">暴力破解/最小计算</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LOL基础数据</title>
    <url>/2019/09/25/Game/LOL%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h5 id="瑞兹"><a href="#瑞兹" class="headerlink" title="瑞兹"></a>瑞兹</h5><ol>
<li>符文<br><img src="https://raw.githubusercontent.com/Wuyiwai/Source/master/%E7%91%9E%E5%85%B9%E7%AC%A6%E6%96%87.png" alt="符文"></li>
</ol>
<a id="more"></a>

<h4 id="提莫"><a href="#提莫" class="headerlink" title="提莫"></a>提莫</h4><ol>
<li>基础数据</li>
</ol>
<table>
<thead>
<tr>
<th>技能</th>
<th>消耗</th>
<th>冷却</th>
<th>范围</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>被动</td>
<td>~</td>
<td>~</td>
<td>~</td>
<td><strong>离开隐形状态，提升攻击速度</strong>，<strong>持续3秒</strong>。</td>
</tr>
<tr>
<td>Q</td>
<td>70/75/80/85/90</td>
<td>8</td>
<td>680</td>
<td></td>
</tr>
<tr>
<td>W</td>
<td>40</td>
<td>17</td>
<td>20</td>
<td></td>
</tr>
<tr>
<td>E</td>
<td>0</td>
<td>8</td>
<td>680</td>
<td></td>
</tr>
<tr>
<td>R</td>
<td>75</td>
<td>0.25</td>
<td>400/650/900</td>
<td></td>
</tr>
</tbody></table>
<ol start="2">
<li>出装<br>纳什之牙 科技枪 面具</li>
</ol>
<h4 id="女枪"><a href="#女枪" class="headerlink" title="女枪"></a>女枪</h4><ol>
<li>基础数据</li>
</ol>
<table>
<thead>
<tr>
<th>技能</th>
<th>消耗</th>
<th>冷却</th>
<th>范围</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>被动</td>
<td>~</td>
<td>~</td>
<td>~</td>
<td><strong>打新的目标更痛</strong>。</td>
</tr>
<tr>
<td>Q</td>
<td>43/46/49/52/55</td>
<td>7/6/5/4/3</td>
<td>650</td>
<td>主动加攻速，<strong>q可减少w的cd</strong></td>
</tr>
<tr>
<td>W</td>
<td>30</td>
<td>12</td>
<td>600</td>
<td></td>
</tr>
<tr>
<td>E</td>
<td>80</td>
<td>18/16/14/12/10</td>
<td>1000</td>
<td></td>
</tr>
<tr>
<td>R</td>
<td>100</td>
<td>120/110/100</td>
<td>400</td>
<td></td>
</tr>
</tbody></table>
<h4 id="莫甘娜"><a href="#莫甘娜" class="headerlink" title="莫甘娜"></a>莫甘娜</h4><ol>
<li>基础数据</li>
</ol>
<table>
<thead>
<tr>
<th>技能</th>
<th>消耗</th>
<th>冷却</th>
<th>范围</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>被动</td>
<td>~</td>
<td>~</td>
<td>~</td>
<td><strong>对英雄，大型小兵，大型野怪技能可以吸血</strong>。</td>
</tr>
<tr>
<td>Q</td>
<td>50/55/60/65/70</td>
<td>11</td>
<td>1250</td>
<td></td>
</tr>
<tr>
<td>W</td>
<td>70/85/100/115/130</td>
<td>12</td>
<td>900</td>
<td></td>
</tr>
<tr>
<td>E</td>
<td>80</td>
<td>26/24/22/20/18</td>
<td>800</td>
<td></td>
</tr>
<tr>
<td>R</td>
<td>100</td>
<td>120/110/100</td>
<td>625</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>率土之滨阵容</title>
    <url>/2019/09/24/Game/%E7%8E%87%E5%9C%9F%E4%B9%8B%E6%BB%A8%E9%98%B5%E5%AE%B9/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>英雄</th>
<th>技能</th>
<th>技能</th>
<th>技能</th>
<th>学习</th>
</tr>
</thead>
<tbody><tr>
<td>陆逊</td>
<td>火势风威</td>
<td>众谋不懈</td>
<td>深谋远虑</td>
<td>列阵</td>
</tr>
<tr>
<td>荀或</td>
<td>驱虎吞狼</td>
<td>反计之策</td>
<td>不攻</td>
<td>乱阵</td>
</tr>
<tr>
<td>曹仁</td>
<td>平壑拒吴</td>
<td>垒实迎击</td>
<td>健卒不怠</td>
<td>利刃</td>
</tr>
<tr>
<td>~</td>
<td>~</td>
<td>~</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>吕布</td>
<td>辕门射戟</td>
<td>人中吕布</td>
<td>一骑当千</td>
<td>地利/齐射</td>
</tr>
<tr>
<td>张春华</td>
<td>强势</td>
<td>浑水摸鱼</td>
<td>始计</td>
<td>地利</td>
</tr>
<tr>
<td>甄洛</td>
<td>落水佳人</td>
<td>磐阵善守</td>
<td>战必断金</td>
<td></td>
</tr>
<tr>
<td>~</td>
<td>~</td>
<td>~</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>灵帝</td>
<td>帝临回光</td>
<td>掎角之势</td>
<td>兼弱攻昧</td>
<td>地利</td>
</tr>
<tr>
<td>曹丕</td>
<td>魏武之泽</td>
<td>疾风迅雷</td>
<td><strong>鱼鳞</strong></td>
<td>地利</td>
</tr>
<tr>
<td>何太后</td>
<td>母仪浮梦</td>
<td><strong>百战精兵</strong></td>
<td>擅兵不寡</td>
<td>固阵</td>
</tr>
<tr>
<td>~</td>
<td>~</td>
<td>~</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>赵云</td>
<td>银龙孤胆</td>
<td>谋定后动</td>
<td>铁戟金戈</td>
<td>利刃</td>
</tr>
<tr>
<td>姜维</td>
<td>其徐如林</td>
<td>重整旗鼓</td>
<td>草木皆兵</td>
<td>地利</td>
</tr>
<tr>
<td>黄忠</td>
<td>定军扬威</td>
<td>步步为营</td>
<td>空城</td>
<td>守备</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>win10重装配置过程</title>
    <url>/2019/10/11/Life/win10%E9%87%8D%E8%A3%85%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>机子是惠普暗影精灵3</p>
</blockquote>
<a id="more"></a>

<h5 id="恢复出厂设置"><a href="#恢复出厂设置" class="headerlink" title="恢复出厂设置"></a>恢复出厂设置</h5><ol>
<li>开机<strong>按Esc</strong>,选择’恢复出厂设置(F11)</li>
<li>这个过程大概要6个钟左右</li>
</ol>
<h5 id="软件选择"><a href="#软件选择" class="headerlink" title="软件选择"></a>软件选择</h5><ol>
<li>Git<ol>
<li><a href="https://segmentfault.com/a/1190000002645623" target="_blank" rel="noopener">git-ssh配置使用</a></li>
<li><a href="https://github.com/xnng/my-git-bash" target="_blank" rel="noopener">git-bash配置</a></li>
<li>git-client选择-sublime merge</li>
</ol>
</li>
<li>7+ Taskbar Tweaker拖至左侧栏<ol>
<li>高级选项 &gt;&gt; no_width_limit &gt;&gt; 1</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>2019周报</title>
    <url>/2019/11/24/Life/2019%E5%91%A8%E6%8A%A5/</url>
    <content><![CDATA[<blockquote>
<p>记录当周看到比较好的文章和资源</p>
</blockquote>
<h5 id="No-46"><a href="#No-46" class="headerlink" title="No.46"></a>No.46</h5><ol>
<li><a href="https://juejin.im/post/5dce584bf265da0bee500802" target="_blank" rel="noopener">美丽的一致性Hash算法</a></li>
<li><a href="https://juejin.im/post/5dce08ae5188254ea020ffaf" target="_blank" rel="noopener">使用Git-Rebase合并多次提交</a></li>
<li><a href="https://mp.weixin.qq.com/s/VIkxGIq6l5BeWDsv4hC7rQ" target="_blank" rel="noopener">面向对象的设计过程</a></li>
</ol>
]]></content>
      <categories>
        <category>WeeklyReport</category>
      </categories>
      <tags>
        <tag>WeeklyReport</tag>
      </tags>
  </entry>
  <entry>
    <title>想了解的知识</title>
    <url>/2019/09/21/Life/%E6%83%B3%E4%BA%86%E8%A7%A3%E7%9A%84%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h4 id="怎么测量时间"><a href="#怎么测量时间" class="headerlink" title="怎么测量时间"></a>怎么测量时间</h4><p><strong>时间的解释</strong>：物质存在的可用钟表来度量的属性。某一过程的发生、发展、终止，既反映了过程的持续性也反映了顺序性。过程的持续性表现为时间间隔，顺序性表现为日期和时刻。</p>
<p>所以可以用某种稳定震荡且可以重复测量的事件来度量。</p>
<p><strong>秒</strong>：铯133原子基态的两个超精细能阶之间跃迁时所辐射的电磁波的周期的9,192,631,770倍 的时间。这个定义提到的铯原子必须在绝对零度时是静止的，而且所在的环境是零磁场。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Git本地多账号工作.md</title>
    <url>/2019/09/03/Git/Git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E5%B7%A5%E4%BD%9C-md/</url>
    <content><![CDATA[<blockquote>
<ol>
<li>最近遇到这样一种情况，在一台电脑上需要设置两个git账号。两个账号都有其作用。所以记录一下设置多账号的过程</li>
<li>参考教程：<a href="https://blog.csdn.net/u014166319/article/details/78570868" target="_blank" rel="noopener">https://blog.csdn.net/u014166319/article/details/78570868</a></li>
</ol>
</blockquote>
<a id="more"></a>

<h3 id="1-分别生成新的公钥和私钥"><a href="#1-分别生成新的公钥和私钥" class="headerlink" title="1. 分别生成新的公钥和私钥"></a>1. 分别生成新的公钥和私钥</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email&quot;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果是单一账号的情况下，默认在.ssh目录下生成id_rsa和id_rsa.pub，但是重复操作会覆盖结果，所以谨记需要针对不同的账号设置不同的文件名，比如id_rsa_jack和id_rsa_tim</li>
<li>mac下一般放在~/.ssh/下</li>
</ol>
<h3 id="2-配置ssh-agent"><a href="#2-配置ssh-agent" class="headerlink" title="2. 配置ssh agent"></a>2. 配置ssh agent</h3><ol>
<li>ssh-agent类似于一个本地的密钥管理器。默认读取的是默认生成的id_rsa，所以要再添加另外一个账号的私钥/<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-agent bash</span><br><span class="line">ssh-add ~&#x2F;.ssh&#x2F;id_rsa</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="3-接下来添加公钥（ssh-keys）到git账号的ssh配置中"><a href="#3-接下来添加公钥（ssh-keys）到git账号的ssh配置中" class="headerlink" title="3. 接下来添加公钥（ssh keys）到git账号的ssh配置中"></a>3. 接下来添加公钥（ssh keys）到git账号的ssh配置中</h3><h3 id="4-配置-ssh-config文件"><a href="#4-配置-ssh-config文件" class="headerlink" title="4. 配置~/.ssh/config文件"></a>4. 配置~/.ssh/config文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;如果不存在，则创建config文件</span><br><span class="line">touch ~&#x2F;.ssh&#x2F;config</span><br></pre></td></tr></table></figure>
<ol>
<li>配置config信息<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#该文件用于配置私钥对应的服务器</span><br><span class="line">#account1(email)</span><br><span class="line"> Host git@github.com</span><br><span class="line"> HostName https:&#x2F;&#x2F;github.com</span><br><span class="line"> User jack &#x2F;&#x2F;这里填写username</span><br><span class="line"> IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_jack</span><br><span class="line">######################################</span><br><span class="line">#account2(email)</span><br><span class="line"> Host git@gitlab.com</span><br><span class="line"> HostName https:&#x2F;&#x2F;gitlab.com</span><br><span class="line"> User tim&#x2F;&#x2F;这里填写username</span><br><span class="line"> IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_tim</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="5-测试是否可以连接git"><a href="#5-测试是否可以连接git" class="headerlink" title="5. 测试是否可以连接git"></a>5. 测试是否可以连接git</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;if success will return</span><br><span class="line">&#x2F;&#x2F;Hi BeginMan! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line">&#x2F;&#x2F;else return </span><br><span class="line">&#x2F;&#x2F;some errors</span><br></pre></td></tr></table></figure>

<h3 id="6-最后，如何切换账号。"><a href="#6-最后，如何切换账号。" class="headerlink" title="6. 最后，如何切换账号。"></a>6. 最后，如何切换账号。</h3><ol>
<li>首先，一般commit的时候，我们会在这之前已经做一步设置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;your_name&quot;</span><br><span class="line">git config --global user.email  &quot;your_email&quot;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>然后，总不能每次切换都手动换一次，所以可以提供两个思路<ol>
<li>可以写个两个shell，一个为changeToTim.sh，一个为changeToJack.sh<ol>
<li>创建shell<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;changeToTim.sh</span><br><span class="line">git config --global user.name &quot;your_name&quot;</span><br><span class="line">git config --global user.email  &quot;your_email&quot;</span><br></pre></td></tr></table></figure></li>
<li>执行shell，切换账户<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;changeToTim.sh</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>sourceTree<ol>
<li>sourceTree本身支持bitbucket账户</li>
<li>需要切换账户时，在commit时，填写commit message的框框左上角有个头像，点击可以设置另外的账号，填写一次，这个库的设置就保存好了。</li>
<li>这个方法比shell来的方便。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h4><ol>
<li>ssh -T <a href="mailto:xx@xx.com">xx@xx.com</a> 提示 <a href="mailto:git@gitee.com">git@gitee.com</a>: Permission denied (publickey).解决如下：<ol>
<li>ssh-add xx/id_rsa</li>
<li>ssh -T <a href="mailto:git@gitee.com">git@gitee.com</a></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常见问题</title>
    <url>/2019/11/23/Git/Git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h6 id="Git-status不能显示中文"><a href="#Git-status不能显示中文" class="headerlink" title="Git status不能显示中文"></a>Git status不能显示中文</h6><ol>
<li>原因: 在默认设置下，中文文件名在工作区状态输出，中文名不能正确显示，而是显示为八进制的字符编码。</li>
<li>解决办法 :将git 配置文件core.quotepath项设置为false。quotepath表示引用路径,加上–global表示全局配置</li>
<li><code>git config --global core.quotepath false</code></li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git使用rebase合并多次提交</title>
    <url>/2019/11/23/Git/Git%E4%BD%BF%E7%94%A8rebase%E5%90%88%E5%B9%B6%E5%A4%9A%E6%AC%A1%E6%8F%90%E4%BA%A4/</url>
    <content><![CDATA[<blockquote>
<p>参考文章</p>
<ol>
<li><a href="https://juejin.im/post/5dce08ae5188254ea020ffaf" target="_blank" rel="noopener">掘金:使用rebase合并提交</a></li>
</ol>
</blockquote>
<a id="more"></a>

<p>想要合并n次提交记录,有两种方法:</p>
<ol>
<li>从HEAD版本开始往后数n个版本<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~n</span><br></pre></td></tr></table></figure></li>
<li>指定一个合并区间 ==startpoint== 和 ==endpoint==, 注意: <strong>该区间指定的是一个前开后闭的区间,意思就是startpoint不参与合并</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i [startpoint] [endpoint]</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>-i 的意思是 ==–interactive==，即弹出交互式的界面让用户编辑完成合并操作</li>
<li><strong>startpoint</strong> 和 <strong>endpoint</strong> 指定了一个编辑区间</li>
<li>如果不指定<strong>endpoint</strong>，则该区间的终点<strong>endpoint</strong>默认是当前分支HEAD所指向的提交</li>
</ul>
<h5 id="实践出真知"><a href="#实践出真知" class="headerlink" title="实践出真知"></a>实践出真知</h5><ol>
<li><code>git log</code>查看提交历史<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前4条是这样: </span><br><span class="line">be7b37c (HEAD -&gt; master) feat: 测试rebase-删除test.txt</span><br><span class="line">05d4baf 测试rebase-1</span><br><span class="line">639e94b 测试rebase</span><br><span class="line">d2a1ecc (origin&#x2F;master, origin&#x2F;HEAD) test1-rebase</span><br></pre></td></tr></table></figure></li>
<li>合并过往三条提交记录, <code>git rebase -i HEAD~3</code>, 交互窗口如下:</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Wuyiwai/Source/master/rebase-1.png" alt="rebase交互弹窗"></p>
<p>操作说明:</p>
<ul>
<li>pick：保留该commit（缩写:p）</li>
<li>reword：保留该commit，但我需要修改该commit的注释（缩写:r）</li>
<li>edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）</li>
<li>squash：将该commit和前一个commit合并（缩写:s）</li>
<li>fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）</li>
<li>exec：执行shell命令（缩写:x）</li>
<li>drop：我要丢弃该commit（缩写:d）</li>
</ul>
<ol start="3">
<li><p>按照需求,我们需要讲commit的内容编辑成如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pick 639e94b 测试rebase</span><br><span class="line">s 05d4baf 测试rebase-1</span><br><span class="line">s be7b37c feat: 测试rebase-删除test.txt</span><br></pre></td></tr></table></figure>
<p>意思是: 把第二第三次的提交都合并到第一次提交上,保留第一次提交.<br>接下来<code>:wq</code>退出.此时git会压缩提交历史.如果这时候有冲突,需要修改,修改的时候要注意,保留最新的历史,不然修改就丢弃了.</p>
</li>
<li><p>如果没有冲突,或者冲突已经解决,会出现如下的编辑窗口<br><img src="https://raw.githubusercontent.com/Wuyiwai/Source/master/rebase-2.png" alt="rebase-2"><br>这是一个编辑commit信息的交互窗口.我们可以在这里编辑最后显示的commit信息<br>我们可以编辑成这样: 只保留了一句总结性的commit信息</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 # This is a combination of 3 commits.</span><br><span class="line"> 2 # This is the 1st commit message:</span><br><span class="line"> 3</span><br><span class="line"> 4 feat: 测试rebase-删除test.txt</span><br><span class="line"> 5</span><br><span class="line"> 6 # Please enter the commit message for your changes. Lines starting</span><br><span class="line"> 7 # with &#39;#&#39; will be ignored, and an empty message aborts the commit.</span><br><span class="line"> 8 #</span><br><span class="line"> 9 # Date:      Sat Nov 23 11:18:26 2019 +0800</span><br><span class="line">10 #</span><br><span class="line">11 # interactive rebase in progress; onto d2a1ecc</span><br><span class="line">12 # Last commands done (3 commands done):</span><br><span class="line">13 #    squash 05d4baf 测试rebase-1</span><br><span class="line">14 #    squash be7b37c feat: 测试rebase-删除test.txt</span><br><span class="line">15 # No commands remaining.</span><br><span class="line">16 # You are currently rebasing branch &#39;master&#39; on &#39;d2a1ecc&#39;.</span><br><span class="line">17 #</span><br><span class="line">18 # Changes to be committed:</span><br><span class="line">19 #       deleted:    test.txt</span><br><span class="line">20 #</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>接下来保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add .  # 将所有修改添加到暂存区</span><br><span class="line">$ git rebase --continue # 继续rebase</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后 <code>git log --oneline</code>查看历史</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">09553ad (HEAD -&gt; master) feat: 测试rebase-删除test.txt</span><br><span class="line">d2a1ecc (origin&#x2F;master, origin&#x2F;HEAD) test1-rebase</span><br><span class="line">22fca5c feat: 更新13-169-191-229</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想要放弃这次压缩, 执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>计划</title>
    <url>/2019/09/15/Life/%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><ul>
<li>FPM模型</li>
<li>Swoole<ul>
<li><a href="https://wiki.swoole.com/#/coroutine/coroutine" target="_blank" rel="noopener">协程</a></li>
<li><a href="https://wiki.swoole.com/#/other/signal" target="_blank" rel="noopener">Linux信号</a></li>
<li>简单应用<ul>
<li><a href="https://zhuanlan.zhihu.com/p/34279200" target="_blank" rel="noopener">发邮件</a></li>
<li><a href="https://github.com/kasuganosoras/SyncMusic" target="_blank" rel="noopener">点歌台</a></li>
</ul>
</li>
<li><a href="https://course.swoole-cloud.com/" target="_blank" rel="noopener">swoole微课程</a></li>
</ul>
</li>
<li>文章<ul>
<li><a href="https://github.com/zhaocong6/Reading" target="_blank" rel="noopener">干货文章</a></li>
</ul>
</li>
<li>面试:<ul>
<li><a href="https://github.com/colinlet/PHP-Interview-QA" target="_blank" rel="noopener">PHP面试问答</a></li>
</ul>
</li>
<li>PHP资源<ul>
<li><a href="https://github.com/shockerli/php-awesome" target="_blank" rel="noopener">常见库</a></li>
</ul>
</li>
</ul>
<h4 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h4><ul>
<li>书籍<ul>
<li><a href="https://juejin.im/book/5bffcbc9f265da614b11b731" target="_blank" rel="noopener">从根儿上理解MySQL</a></li>
<li>极客时间 - MySQl45讲</li>
</ul>
</li>
<li>文章<ul>
<li><a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">MySQL索引原理及慢查询优化</a></li>
</ul>
</li>
</ul>
<h3 id="方案实现"><a href="#方案实现" class="headerlink" title="方案实现"></a>方案实现</h3><ul>
<li><a href="https://mp.weixin.qq.com/s/tM3QVIdNtPW3x0w--LRy3Q" target="_blank" rel="noopener">延时队列</a></li>
</ul>
<h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><ul>
<li><a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527" target="_blank" rel="noopener">Redis深度历险</a></li>
<li><a href="https://mp.weixin.qq.com/s/UvNn1PMfncVhfADI9k8EWQ" target="_blank" rel="noopener">Redis应用场景</a></li>
<li><a href="https://juejin.im/post/5b99d4bce51d450e7a24b66e" target="_blank" rel="noopener">互联网公司面试必问的Redis题目</a></li>
</ul>
<h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4><ul>
<li><a href="https://github.com/xjh22222228/git-manual" target="_blank" rel="noopener">Git常用命令</a></li>
<li><a href="https://juejin.im/post/5e4d2bdee51d4527086b3389" target="_blank" rel="noopener">图解常用的Git指令含义</a></li>
<li><a href="https://github.com/geeeeeeeeek/git-recipes" target="_blank" rel="noopener">高质量Git中文教程</a></li>
<li><a href="https://github.com/phodal/github" target="_blank" rel="noopener">Git漫游指南</a></li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><a href="https://segmentfault.com/a/1190000021551892" target="_blank" rel="noopener">HTTP</a></li>
<li><a href="https://learnku.com/articles/39302" target="_blank" rel="noopener">业务逻辑开发套路三板斧</a></li>
</ul>
<h4 id="算法和数据结构"><a href="#算法和数据结构" class="headerlink" title="算法和数据结构"></a>算法和数据结构</h4><ul>
<li><a href="https://zhimap.com/mmap/e49ebcfd59774f0fa0e708817e8a5d3e" target="_blank" rel="noopener">算法 - 思维导图</a></li>
<li><a href="https://mp.weixin.qq.com/s/PXt3wfAOvvrWleOBsIAgnA" target="_blank" rel="noopener">十大排序算法动画演示</a></li>
<li>必看<ol>
<li><a href="https://github.com/labuladong/fucking-algorithm" target="_blank" rel="noopener">fucking-algorithm</a></li>
<li><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=3#/detail/pc?id=28" target="_blank" rel="noopener">300分钟搞定算法面试</a></li>
</ol>
</li>
</ul>
<h4 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h4><ol>
<li><a href="https://github.com/0voice/interview_internal_reference" target="_blank" rel="noopener">面试题目集锦</a></li>
<li><a href="https://github.com/toutiaoio/awesome-architecture" target="_blank" rel="noopener">架构师实例</a></li>
<li><a href="https://github.com/aisuhua/restful-api-design-references" target="_blank" rel="noopener">Restful api设计指南</a></li>
<li><a href="https://github.com/guanguans/design-patterns-for-humans-cn" target="_blank" rel="noopener">设计模式</a></li>
<li><a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md" target="_blank" rel="noopener">命令行的艺术</a></li>
<li><a href="https://github.com/xingshaocheng/architect-awesome" target="_blank" rel="noopener">后端架构师技术图谱</a></li>
<li><a href="https://github.com/P-P-X/awesome-collector" target="_blank" rel="noopener">架构</a></li>
<li><a href="https://github.com/judasn/Linux-Tutorial" target="_blank" rel="noopener">走进linux</a></li>
</ol>
<p>优先级:<br>Swoole &gt; MySQL &gt; Redis &gt; 方案</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下配置PHP和Swoole环境</title>
    <url>/2019/09/13/PHP/Mac%E4%B8%8B%E9%85%8D%E7%BD%AEPHP%E5%92%8CSwoole%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<blockquote>
<p>记录一下配置Swoole环境的过程</p>
</blockquote>
<p>前言: 本身Mac是自带了php的.通过<code>php -v</code>可以看到自带php版本是php7.1.略旧.直接上手php7.3.</p>
<a id="more"></a>

<h5 id="准备工作-安装php和一些依赖"><a href="#准备工作-安装php和一些依赖" class="headerlink" title="准备工作,安装php和一些依赖"></a>准备工作,安装php和一些依赖</h5><ul>
<li><p>brew install php(默认安装最新的).这个过程大部分时间取决于网速.</p>
</li>
<li><p>brew的最后会执行<code>make install</code>.</p>
</li>
<li><p>如果<code>brew install xxx</code>成功,brew安装好的位置在<code>/usr/local/Cellar/</code>目录下;比如刚安装好的php 7.3的目录就为<code>/usr/local/Cellar/php/7.3.9/bin/php</code></p>
</li>
<li><p>此时在cli环境中使用php -v显示的还是7.1.因为cli环境加载的配置是默认的php路径.所以要替换成刚安装的php7.3的版本.可以用<code>where php</code>查看php安装在哪里.如下</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ where php</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;php&#x2F;7.3.9&#x2F;bin&#x2F;php(这个可以)</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;php(这个也可以)</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;php</span><br></pre></td></tr></table></figure></li>
<li><p>替换默认的php版本.</p>
<ul>
<li><p>假设用的是oh my zsh</p>
</li>
<li><p>vim ~/.zshrc</p>
</li>
<li><p>export PATH=/usr/local/Cellar/php/7.3.9/bin:$PATH</p>
</li>
<li><p>source ~/.zshrc</p>
</li>
<li><p>php -v检查是否生效</p>
</li>
<li><p>php.ini文件位于<code>/usr/local/etc/php/7.3/php.ini</code>.也可以用<code>php --ini</code>来定位.ini<br>如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php --ini</span><br><span class="line">Configuration File (php.ini) Path: &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;7.3</span><br><span class="line">Loaded Configuration File:         &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;7.3&#x2F;php.ini</span><br><span class="line">Scan for additional .ini files in: &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;7.3&#x2F;conf.d</span><br><span class="line">Additional .ini files parsed:      &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;7.3&#x2F;conf.d&#x2F;ext-opcache.ini</span><br></pre></td></tr></table></figure></li>
<li><p>可以通过查看<code>php.ini</code>或者<code>phpinfo()</code>查看extension在/usr/local/lib/php/pecl/20180731</p>
</li>
</ul>
</li>
</ul>
<h5 id="编译swoole"><a href="#编译swoole" class="headerlink" title="编译swoole"></a>编译swoole</h5><blockquote>
<p>参考资料:</p>
<ol>
<li><a href="https://wiki.swoole.com/wiki/page/6.html" target="_blank" rel="noopener">官方编译指南</a></li>
</ol>
</blockquote>
<ul>
<li><a href="https://github.com/swoole/swoole-src/releases" target="_blank" rel="noopener">下载releases包</a></li>
<li>解压该releases包,重命名为swoole</li>
<li>接下来新手编译示例:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd swoole</span><br><span class="line">$ phpize </span><br><span class="line">$ .&#x2F;configure</span><br><span class="line">$ make </span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure></li>
<li>编译完成后,在<code>/usr/local/lib/php/pecl/20180731</code>.下会有swoole.so</li>
<li>最后,修改<code>php.ini</code>,加入<code>extension=swoole.so</code></li>
<li>最后,<code>php -m</code>或者<code>phpinfo()</code>.查看是否成功加载swoole.so</li>
<li>这里做一下解释:phpize会检测php环境和生成对应configure文件.此时用的php版本和依赖取决于cli环境下制定的版本和对应的ini,conf等配置.所以此时用的是php7.3</li>
</ul>
]]></content>
      <categories>
        <category>PHP</category>
        <category>Swoole</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Swoole</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP FastCGI 进程管理器（FPM）</title>
    <url>/2019/09/04/PHP/PHP-FastCGI-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%88FPM%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>参考文章</p>
<ol>
<li><a href="https://www.php.net/manual/zh/install.fpm.php" target="_blank" rel="noopener">PHP-manual</a></li>
<li><a href="https://baike.baidu.com/item/fastcgi" target="_blank" rel="noopener">百度百科-fastcgi</a></li>
<li><a href="https://cloud.tencent.com/developer/news/326669" target="_blank" rel="noopener">LAMP架构下的模型分析</a></li>
</ol>
</blockquote>
<a id="more"></a>

<h5 id="CGI是什么"><a href="#CGI是什么" class="headerlink" title="CGI是什么"></a>CGI是什么</h5><p>CGI全称是“通用网关接口”(Common Gateway Interface)，web服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序一般运行在网络服务器上。 CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php,perl,tcl等。</p>
<h5 id="FastCGI是什么"><a href="#FastCGI是什么" class="headerlink" title="FastCGI是什么"></a>FastCGI是什么</h5><ol>
<li>FastCGI全称<strong>快速通用网关接口</strong>(FastCommonGatewayInterface).</li>
<li>FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次(这是CGI最为人诟病的fork-and-execute 模式)。</li>
<li>它还支持分布式的运算, 即FastCGI程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。</li>
<li>FastCGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail- Over特性等等</li>
</ol>
<h5 id="PHP-FPM-PHP-FastCGI-Process-Manager-是什么"><a href="#PHP-FPM-PHP-FastCGI-Process-Manager-是什么" class="headerlink" title="PHP-FPM(PHP FastCGI Process Manager)是什么"></a>PHP-FPM(PHP FastCGI Process Manager)是什么</h5><ol>
<li>PHP-FPM是一个PHP FastCGI的进程管理器,管理PHP进程池.主要可以有效地控制内存和进程,可以平滑重载PHP配置</li>
<li>PHP-FPM是因为PHP-FastCgi的出现,可以管理php-fastcgi</li>
<li>简单点来说就是PHP-FPM管理启动一个masger进程和多个worker进程的程序.</li>
<li>PHP-FPM是多进程模式,每个子进程是单一线程,通过master进程管理worker进程.启动进程的方式可以分为动态模式和静态模式.<ol>
<li>动态模式(dynamic)<ol>
<li>一开始开启一定数量的PHP-FPM进程,请求量变多,动态增加进程数;空闲时释放.</li>
</ol>
</li>
<li>静态模式(static)<ol>
<li>子进程的数量是固定的(<strong>配置项:pm.max_children</strong>)</li>
</ol>
</li>
<li>按需分配(ondemand)</li>
<li>配置项:<ol>
<li><strong>pm.max_children</strong>—-pm设置为 static 时表示创建的子进程的数量，pm 设置为 dynamic 时表示最大可创建的子进程的数量。必须设置。</li>
<li><strong>pm.start_servers</strong>—-设置启动时创建的子进程数目。仅在 pm 设置为 dynamic 时使用。默认值：min_spare_servers + (max_spare_servers - min_spare_servers) / 2。</li>
<li><strong>pm.min_spare_servers</strong>—-设置空闲服务进程的最低数目。仅在 pm 设置为 dynamic 时使用。必须设置。</li>
<li><strong>pm.max_spare_servers</strong>—-设置空闲服务进程的最大数目。仅在 pm 设置为 dynamic 时使用。必须设置。</li>
</ol>
</li>
<li>如何选择<ol>
<li>看业务.<ol>
<li>看业务的请求是什么类型的.全天平稳,可以预测的峰值?还是峰值不定类似于微博爆题这种.如果是全天稳定,或者说峰值可以预测的.看机器静态模式固定进程数能否轻松抗住,如果可以,进程数适当调整一下,保证抗压的2-3倍即可选用静态模式.如果是峰值不定的且分分钟可能超出预期的,可以考虑选用动态,并且结合DBA扩容.</li>
</ol>
</li>
<li>看配置.高配选静态,低配选动态.</li>
</ol>
</li>
</ol>
</li>
<li>优缺点分析:<ol>
<li>进程模型是多进程同步阻塞.一个进程处理一个链接.最大的优势就是稳定可靠,编程简单.</li>
<li>明显的缺点是:处理大规模并发的长连接的时候吃力.阻塞容易成为痛点.</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>Python PEP8编码规范</title>
    <url>/2019/09/03/Python/Python-PEP8%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<blockquote>
<p>参考资料</p>
</blockquote>
<ol>
<li><a href="https://legacy.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP 8 – Style Guide for Python Code</a></li>
<li><a href="https://blog.csdn.net/ratsniper/article/details/78954852" target="_blank" rel="noopener">PEP8中文翻译</a></li>
</ol>
<a id="more"></a>

<h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><ul>
<li>每一级缩进使用4个空格。</li>
<li>续行应该与其包裹元素对齐，要么使用圆括号、方括号和花括号内的隐式行连接来垂直对齐，要么使用挂行缩进对齐3。当使用挂行缩进时，应该考虑到第一行不应该有参数，以及使用缩进以区分自己是续行。</li>
<li>推荐：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 与左括号对齐</span><br><span class="line">foo &#x3D; long_function_name(var_one, var_two,</span><br><span class="line">                         var_three, var_four)</span><br><span class="line"></span><br><span class="line"># 用更多的缩进来与其他行区分</span><br><span class="line">def long_function_name(</span><br><span class="line">        var_one, var_two, var_three,</span><br><span class="line">        var_four):</span><br><span class="line">    print(var_one)</span><br><span class="line"></span><br><span class="line"># 挂行缩进应该再换一行</span><br><span class="line">foo &#x3D; long_function_name(</span><br><span class="line">    var_one, var_two,</span><br><span class="line">    var_three, var_four)</span><br></pre></td></tr></table></figure></li>
<li>不推荐：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 没有使用垂直对齐时，禁止把参数放在第一行</span><br><span class="line">foo &#x3D; long_function_name(var_one, var_two,</span><br><span class="line">    var_three, var_four)</span><br><span class="line"></span><br><span class="line"># 当缩进没有与其他行区分时，要增加缩进</span><br><span class="line">def long_function_name(</span><br><span class="line">    var_one, var_two, var_three,</span><br><span class="line">    var_four):</span><br><span class="line">    print(var_one)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="行的最大长度"><a href="#行的最大长度" class="headerlink" title="行的最大长度"></a>行的最大长度</h4><ol>
<li>所有行限制的最大字符数为79。</li>
<li>没有结构化限制的大块文本（文档字符或者注释），每行的最大字符数限制在72。 </li>
</ol>
<h4 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h4><ol>
<li>顶层函数和类的定义，前后用两个空行隔开。 </li>
<li>类里的方法定义用一个空行隔开。 </li>
</ol>
<h4 id="Imports-导入"><a href="#Imports-导入" class="headerlink" title="Imports 导入"></a>Imports 导入</h4><ul>
<li>导入通常在分开的行，例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">推荐: import os</span><br><span class="line">     import sys</span><br><span class="line"></span><br><span class="line">不推荐:  import sys, os</span><br><span class="line">也可以：</span><br><span class="line">from subprocess import Popen, PIPE</span><br></pre></td></tr></table></figure></li>
<li>导入总是位于文件的顶部，在模块注释和文档字符串之后，在模块的全局变量与常量之前。 </li>
<li>导入应该按照以下顺序分组：<ol>
<li>标准库导入</li>
<li>相关第三方库导入</li>
<li>本地应用/库特定导入 </li>
<li>你应该在每一组导入之间加入空行。</li>
</ol>
</li>
<li>推荐使用绝对路径导入，如果导入系统没有正确的配置（比如包里的一个目录在sys.path里的路径后），使用绝对路径会更加可读并且性能更好（至少能提供更好的错误信息）:</li>
</ul>
<h4 id="Comments-注释"><a href="#Comments-注释" class="headerlink" title="Comments 注释"></a>Comments 注释</h4><ol>
<li>与代码相矛盾的注释比没有注释还糟，当代码更改时，优先更新对应的注释！</li>
<li>注释应该是完整的句子。如果一个注释是一个短语或句子，它的第一个单词应该大写，除非它是以小写字母开头的标识符(永远不要改变标识符的大小写！)。 </li>
<li>如果注释很短，结尾的句号可以省略。块注释一般由完整句子的一个或多个段落组成，并且每句话结束有个句号。 </li>
<li>在句尾结束的时候应该使用两个空格。 </li>
<li>当用英文书写时，遵循Strunk and White （译注：《Strunk and White, The Elements of Style》）的书写风格。 </li>
<li>在非英语国家的Python程序员，请使用英文写注释，除非你120%的确信你的代码不会被使用其他语言的人阅读。</li>
</ol>
<h4 id="Block-Comments-块注释"><a href="#Block-Comments-块注释" class="headerlink" title="Block Comments 块注释"></a>Block Comments 块注释</h4><ol>
<li>块注释通常适用于跟随它们的某些（或全部）代码，并缩进到与代码相同的级别。块注释的每一行开头使用一个#和一个空格（除非块注释内部缩进文本）。 </li>
<li>块注释内部的段落通过只有一个#的空行分隔。</li>
</ol>
<h4 id="Inline-Comments-行内注释"><a href="#Inline-Comments-行内注释" class="headerlink" title="Inline Comments 行内注释"></a>Inline Comments 行内注释</h4><p>1.有节制地使用行内注释。<br>2.行内注释是与代码语句同行的注释。行内注释和代码至少要有两个空格分隔。注释由#和一个空格开始。<br>3. 事实上，如果状态明显的话，行内注释是不必要的，反而会分散注意力。比如说后面这样就不需要：<code>x = x + 1 # Increment x</code>但有时，这样做很有用：<code>x = x + 1 # Compensate for border</code></p>
<h4 id="Documentation-Strings-文档字符串"><a href="#Documentation-Strings-文档字符串" class="headerlink" title="Documentation Strings 文档字符串"></a>Documentation Strings 文档字符串</h4><ul>
<li>要为所有的公共模块，函数，类以及方法编写文档说明。</li>
<li>非公共的方法没有必要，但是应该有一个描述方法具体作用的注释。这个注释应该在def那一行之后。</li>
<li><a href="http://legacy.python.org/dev/peps/pep-0257/" target="_blank" rel="noopener">PEP 257</a>描述了写出好的文档说明相关的约定。特别需要注意的是，多行文档说明使用的结尾三引号应该自成一行，例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;Return a foobang</span><br><span class="line"></span><br><span class="line">Optional plotz says to frobnicate the bizbaz first.</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure></li>
<li>对于单行的文档说明，尾部的三引号应该和文档在同一行。</li>
</ul>
<h4 id="约定俗成的命名约定"><a href="#约定俗成的命名约定" class="headerlink" title="约定俗成的命名约定"></a>约定俗成的命名约定</h4><ul>
<li><p><strong>Names to Avoid 应避免的名字</strong></p>
<ol>
<li>永远不要使用字母‘l’（小写的L），‘O’（大写的O），或者‘I’（大写的I）作为单字符变量名。 </li>
<li>在有些字体里，这些字符无法和数字0和1区分，如果想用‘l’，用‘L’代替。</li>
</ol>
</li>
<li><p><strong>Class Names 类名</strong></p>
<ol>
<li>类名一般使用首字母大写的约定。 </li>
<li>在接口被文档化并且主要被用于调用的情况下，可以使用函数的命名风格代替。 </li>
<li>注意，对于内置的变量命名有一个单独的约定：大部分内置变量是单个单词（或者两个单词连接在一起），首字母大写的命名法只用于异常名或者内部的常量。</li>
</ol>
</li>
<li><p><strong>Function Names 函数名</strong></p>
<ol>
<li>函数名应该小写，如果想提高可读性可以用下划线分隔。 </li>
<li>大小写混合仅在为了兼容原来主要以大小写混合风格的情况下使用（比如 threading.py），保持向后兼容性。</li>
</ol>
</li>
<li><p><strong>Function and method arguments 函数和方法参数</strong></p>
<ol>
<li>始终要将 self 作为实例方法的的第一个参数。 </li>
<li>始终要将 cls 作为类静态方法的第一个参数。 </li>
<li>如果函数的参数名和已有的关键词冲突，在最后加单一下划线比缩写或随意拼写更好。因此 class_ 比 clss 更好。（也许最好用同义词来避免这种冲突）</li>
</ol>
</li>
<li><p><strong>Programming Recommendations 编程建议</strong></p>
<ol>
<li>代码应该用不损害其他Python实现的方式去编写（PyPy，Jython，IronPython，Cython，Psyco 等）。 比如，不要依赖于在CPython中高效的内置字符连接语句 a += b 或者 a = a + b。这种优化甚至在CPython中都是脆弱的（它只适用于某些类型）并且没有出现在不使用引用计数的实现中。在性能要求比较高的库中，可以种 ”.join() 代替。这可以确保字符关联在不同的实现中都可以以线性时间发生。</li>
<li>和像None这样的单例对象进行比较的时候应该始终用 is 或者 is not，永远不要用等号运算符。<br>另外，如果你在写 if x 的时候，请注意你是否表达的意思是 if x is not None。举个例子，当测试一个默认值为None的变量或者参数是否被设置为其他值的时候。这个其他值应该是在上下文中能成为bool类型false的值。</li>
<li>使用 is not 运算符，而不是 not … is 。虽然这两种表达式在功能上完全相同，但前者更易于阅读，所以优先考虑。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">推荐: if foo is not None</span><br><span class="line">不推荐：if not foo is None:</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol>
<li>Yapf在Pycharm中的应用<ol>
<li>本地安装yapf插件 pip install yapf</li>
<li>pycharm-&gt;Preferences-&gt;Tools-&gt;External Tools-&gt;add</li>
<li>参考配置：<ol>
<li>Name: yapf</li>
<li>Programe: yapf</li>
<li>Arguments: -i $FilePath$</li>
<li>Working directory: $ProjectFileDir$</li>
</ol>
</li>
<li>用法：<ol>
<li>Preferences-&gt;keymap-&gt;External Tools-&gt;papf-&gt;Add Keyboard Shortcut把yapf的快捷键改成Ctrl+Cmd+L</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP GUI</title>
    <url>/2019/09/21/PHP/PHP-GUI/</url>
    <content><![CDATA[<blockquote>
<p>参考来源</p>
<ol>
<li><a href="https://www.php.net/manual/zh/ui.setup.php" target="_blank" rel="noopener">PHP-GUI</a></li>
<li><a href="https://www.wxphp.org/gallery" target="_blank" rel="noopener">wxphp</a></li>
</ol>
</blockquote>
<p>todo: 可以试试</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP yield</title>
    <url>/2019/10/12/PHP/PHP-yield/</url>
    <content><![CDATA[<blockquote>
<p>参考文档</p>
<ol>
<li><a href="https://www.php.net/manual/zh/language.generators.overview.php" target="_blank" rel="noopener">PHP yield</a></li>
</ol>
</blockquote>
<a id="more"></a>

<h5 id="有个坑"><a href="#有个坑" class="headerlink" title="有个坑"></a>有个坑</h5><blockquote>
<p>When a generator function is called for the first time, an object of the internal Generator class is returned. This object implements the Iterator interface in much the same way as a forward-only iterator object would, and provides methods that can be called to manipulate the state of the generator, including sending values to and returning values from it.</p>
</blockquote>
<p>在一个生成器方法中,当被第一次调用时就会指定返回Generator类型的对象.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function gen_one_to_three($flag) &#123;</span><br><span class="line">    if ($flag) &#123;</span><br><span class="line">        for ($i &#x3D; 1; $i &lt;&#x3D; 3; $i++) &#123;</span><br><span class="line">            yield $i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        echo &quot;sss&quot;;</span><br><span class="line">        return [1,2,3];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">$generator &#x3D; gen_one_to_three(false);</span><br><span class="line">var_dump($generator);</span><br><span class="line">foreach ($generator as $value) &#123;</span><br><span class="line">    echo &quot;$value\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时不管怎么样都是返回Generator类型的对象,无关if的条件</p>
<h5 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function gen_one_to_three() &#123;</span><br><span class="line">    for ($i &#x3D; 1; $i &lt;&#x3D; 3; $i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;注意变量$i的值在不同的yield之间是保持传递的。</span><br><span class="line">        yield $i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$generator &#x3D; gen_one_to_three();</span><br><span class="line">foreach ($generator as $value) &#123;</span><br><span class="line">    echo &quot;$value\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>注意:在内部会为生成的值配对连续的整型索引，就像一个非关联的数组。</p>
<h5 id="Caution"><a href="#Caution" class="headerlink" title="Caution"></a>Caution</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果在一个表达式上下文(例如在一个赋值表达式的右侧)中使用yield，你必须使用圆括号把yield申明包围起来。 例如这样是有效的：</span><br><span class="line"></span><br><span class="line">$data &#x3D; (yield $value);</span><br><span class="line">而这样就不合法，并且在PHP5中会产生一个编译错误：</span><br><span class="line"></span><br><span class="line">$data &#x3D; yield $value;</span><br><span class="line">The parenthetical restrictions do not apply in PHP 7.</span><br><span class="line"></span><br><span class="line">这个语法可以和生成器对象的Generator::send()方法配合使用。</span><br></pre></td></tr></table></figure>

<h5 id="关于内存的例子"><a href="#关于内存的例子" class="headerlink" title="关于内存的例子"></a>关于内存的例子</h5><ol>
<li>正常使用foreach迭代数组</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getValues() &#123;</span><br><span class="line">    $valuesArray &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F; 获取初始内存使用量</span><br><span class="line">    echo round(memory_get_usage() &#x2F; 1024 &#x2F; 1024, 2) . &#39; MB&#39; . PHP_EOL;</span><br><span class="line">    for ($i &#x3D; 1; $i &lt; 800000; $i++) &#123;</span><br><span class="line">        $valuesArray[] &#x3D; $i;</span><br><span class="line">        &#x2F;&#x2F; 为了让我们能进行分析，所以我们测量一下内存使用量</span><br><span class="line">        if (($i % 200000) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 来 MB 为单位获取内存使用量</span><br><span class="line">            echo round(memory_get_usage() &#x2F; 1024 &#x2F; 1024, 2) . &#39; MB&#39;. PHP_EOL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $valuesArray;</span><br><span class="line">&#125;</span><br><span class="line">$myValues &#x3D; getValues(); &#x2F;&#x2F; 一旦我们调用函数将会在这里创建数组</span><br><span class="line">foreach ($myValues as $value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">0.34 MB</span><br><span class="line">8.34 MB</span><br><span class="line">16.34 MB</span><br><span class="line">32.34 MB</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用yield返回可迭代对象<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getValues() &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取内存使用数据</span><br><span class="line">    echo round(memory_get_usage() &#x2F; 1024 &#x2F; 1024, 2) . &#39; MB&#39; . PHP_EOL;</span><br><span class="line">    for ($i &#x3D; 1; $i &lt; 800000; $i++) &#123;</span><br><span class="line">        yield $i;</span><br><span class="line">        &#x2F;&#x2F; 做性能分析，因此可测量内存使用率</span><br><span class="line">        if (($i % 200000) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 内存使用以 MB 为单位</span><br><span class="line">            echo round(memory_get_usage() &#x2F; 1024 &#x2F; 1024, 2) . &#39; MB&#39;. PHP_EOL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$myValues &#x3D; getValues(); &#x2F;&#x2F; 在循环之前都不会有动作</span><br><span class="line">foreach ($myValues as $value) &#123;&#125; &#x2F;&#x2F; 开始生成数据</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">0.34 MB</span><br><span class="line">0.34 MB</span><br><span class="line">0.34 MB</span><br><span class="line">0.34 MB</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol>
<li>yield返回的是一个继承了Iterator的可迭代对象</li>
<li>yield的好处:<ol>
<li>一个生成器允许我们使用循环来迭代一维数组的代码，而不需要在内存中创建是一个数组，这可能会导致超出内存限制。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>PhpStorm使用</title>
    <url>/2019/10/24/PHP/PHPstorm%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>参考文章</p>
<ol>
<li><a href="https://phpstorm.tips/tips/" target="_blank" rel="noopener">PHPstorm Tips</a></li>
<li><a href="https://www.bilibili.com/video/av40212757?from=search&seid=9863044042153804342" target="_blank" rel="noopener">Be Awesome in PHPStorm</a></li>
</ol>
</blockquote>
<p>记录PhpStorm使用技巧和使用中遇到的问题</p>
<a id="more"></a>

<h5 id="日常使用"><a href="#日常使用" class="headerlink" title="日常使用"></a>日常使用</h5><ol>
<li>主题<ol>
<li><a href="http://plugins.jetbrains.com/plugin/8006-material-theme-ui" target="_blank" rel="noopener">Material theme ui</a></li>
</ol>
</li>
<li>快速操作<ol>
<li>F2 快速跳到error处</li>
</ol>
</li>
</ol>
<h5 id="使用遇到的问题"><a href="#使用遇到的问题" class="headerlink" title="使用遇到的问题"></a>使用遇到的问题</h5><ol>
<li>PHPstorm升级后无法保存sftp的配置,提示<code>user name is specified</code><ol>
<li>原因:phpstorm默认使用mac的keychain来处理密码,可能在升级过程中删除了keychain的key</li>
<li>解决办法：PHPstorm preferences &gt; Passwords &gt; In Keepass</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP代码技巧</title>
    <url>/2019/09/03/PHP/PHP%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>记录一些比较实用的实践</p>
<a id="more"></a>
<ul>
<li><p>求两个时间间隔的时间戳</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$date1 &#x3D; strtotime(&quot;2019-11-28 15:39:00&quot;);</span><br><span class="line">$date2 &#x3D; strtotime(&quot;2019-11-18 15:39:00&quot;);</span><br><span class="line">$diff&#x3D; $date1 - $date2 ;</span><br><span class="line">var_dump($diff);</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.php.net/manual/zh/function.list.php" target="_blank" rel="noopener">list</a>-把数组中的值赋给一组变量</p>
<ul>
<li>在 PHP 7.1.0 之前的版本，list() 仅能用于数字索引的数组，并假定数字索引从 0 开始。</li>
<li>像array()一样,这不是真正的函数，而是语言结构</li>
<li>PHP 5 里，list() 从最右边的参数开始赋值； PHP 7 里，list() 从最左边的参数开始赋值<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;一个简单的例子</span><br><span class="line">$info &#x3D; array(&#39;coffee&#39;, &#39;brown&#39;, &#39;caffeine&#39;);</span><br><span class="line">list($drink, $color, $power) &#x3D; $info;</span><br><span class="line">echo &quot;$drink is $color and $power makes it special.\n&quot;;</span><br><span class="line">list($drink, , $power) &#x3D; $info;</span><br><span class="line">echo &quot;$drink has $power.\n&quot;;...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><a href="https://www.php.net/manual/en/language.operators.comparison.php" target="_blank" rel="noopener">飞船操作符 &lt;=&gt;</a></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;一个简单的例子</span><br><span class="line">&#x2F;&#x2F; Integers</span><br><span class="line">echo 1 &lt;&#x3D;&gt; 1; &#x2F;&#x2F; 0</span><br><span class="line">echo 1 &lt;&#x3D;&gt; 2; &#x2F;&#x2F; -1</span><br><span class="line">echo 2 &lt;&#x3D;&gt; 1; &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://www.php.net/manual/zh/language.generators.php" target="_blank" rel="noopener">yield</a></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function gen_one_to_three() &#123;</span><br><span class="line">    for ($i &#x3D; 1; $i &lt;&#x3D; 3; $i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;注意变量$i的值在不同的yield之间是保持传递的。</span><br><span class="line">        yield $i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$generator &#x3D; gen_one_to_three();</span><br><span class="line">foreach ($generator as $value) &#123;</span><br><span class="line">    echo &quot;$value\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>输出当前目录:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#96;ls&#96;;</span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://www.php.net/manual/zh/control-structures.switch.php" target="_blank" rel="noopener">switch</a></p>
<ul>
<li>switch的continue 2;</li>
<li>注意和其它语言不同，continue 语句作用到 switch 上的作用类似于 break。如果在循环中有一个 switch 并希望 continue 到外层循环中的下一轮循环，用 continue 2。</li>
</ul>
</li>
<li><p>变量名引用</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;反正我觉得这玩意儿慎用</span><br><span class="line">$foo &#x3D; &quot;Hello&quot;;</span><br><span class="line">$bar &#x3D; &quot;foo&quot;;</span><br><span class="line">echo $$bar;</span><br><span class="line">输出: Hello</span><br><span class="line"></span><br><span class="line">同理:</span><br><span class="line">function test()&#123;</span><br><span class="line">    echo &#39;hello world!&#39;;</span><br><span class="line">&#125;</span><br><span class="line">$fn &#x3D; &#39;test&#39;;</span><br><span class="line">$fn();</span><br><span class="line">输出: hello world!</span><br></pre></td></tr></table></figure></li>
<li><p><a href="">PHP过滤器</a>filter_var</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以用来过滤邮箱</span><br><span class="line">var_dump(filter_var(&#39;bob@example.com&#39;, FILTER_VALIDATE_EMAIL));</span><br><span class="line">输出:string(15) &quot;bob@example.com&quot;</span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://www.php.net/manual/zh/function.ip2long.php" target="_blank" rel="noopener">ip2long</a>—-将IPV4 的字符串互联网协议转换成长整型数字</p>
</li>
<li><p>array_column</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$arr &#x3D; [</span><br><span class="line">    [</span><br><span class="line">        &#39;name&#39; &#x3D;&gt; &#39;bob&#39;,</span><br><span class="line">        &#39;email&#39; &#x3D;&gt; &quot;89@qq.com&quot;,</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        &#39;name&#39; &#x3D;&gt; &quot;tom&quot;,</span><br><span class="line">        &#39;email&#39; &#x3D;&gt; &quot;85@qq.com&quot;,</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        &#39;name&#39; &#x3D;&gt; &quot;8om&quot;,</span><br><span class="line">        &#39;email&#39; &#x3D;&gt; &quot;85@qq.com&quot;,</span><br><span class="line">    ]</span><br><span class="line">];</span><br><span class="line">$ret &#x3D; array_column($arr, null, &#39;email&#39;);</span><br><span class="line">print_r($ret);</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [89@qq.com] &#x3D;&gt; Array</span><br><span class="line">        (</span><br><span class="line">            [name] &#x3D;&gt; bob</span><br><span class="line">            [email] &#x3D;&gt; 89@qq.com</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    [85@qq.com] &#x3D;&gt; Array</span><br><span class="line">        (</span><br><span class="line">            [name] &#x3D;&gt; 8om</span><br><span class="line">            [email] &#x3D;&gt; 85@qq.com</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">Tips: 后面覆盖前面的值&#x3D;&gt;如8om覆盖tom</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP实现一些奇奇怪怪的需求</title>
    <url>/2019/10/22/PHP/PHP%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%BA%9B%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E9%9C%80%E6%B1%82/</url>
    <content><![CDATA[<blockquote>
<p>记录一些日常生活中比较奇怪的需求实现</p>
</blockquote>
<a id="more"></a>

<ol>
<li>字符串过滤除ASCII码之外的字符,使用场景:数据库字符集设置为ASCII,而数据来源有其他字符集的数据时<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">preg_replace(&#39;&#x2F;[^(\x20-\x7F)]*&#x2F;&#39;,&#39;&#39;, trim(strtolower($email)))</span><br></pre></td></tr></table></figure></li>
<li>根据多项key对多维数组进行排序.类似order by 多项<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 根据多项key对多维数组进行排序.类似order by 多项</span><br><span class="line">     * @param array $arr</span><br><span class="line">     * @param array $sortOption</span><br><span class="line">     * @return array|mixed</span><br><span class="line">     * $sortOption &#x3D; [</span><br><span class="line">     *      &#39;unread_count&#39; &#x3D;&gt; SORT_DESC,</span><br><span class="line">     *      &#39;receive_time&#39; &#x3D;&gt; SORT_DESC,</span><br><span class="line">     * ];</span><br><span class="line">     * $arr &#x3D; [</span><br><span class="line">     *      [</span><br><span class="line">     *          &#39;receive_time&#39; &#x3D;&gt; 0,</span><br><span class="line">     *          &#39;unread_count&#39; &#x3D;&gt; 200,</span><br><span class="line">     *      ],</span><br><span class="line">     * ];</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static function sortByManyFields(array $arr &#x3D; [], array $sortOption &#x3D; [])</span><br><span class="line">    &#123;</span><br><span class="line">        if (empty($arr) || empty($sortOption)) return [];</span><br><span class="line">        $data &#x3D; [];</span><br><span class="line">        foreach ($arr as $index &#x3D;&gt; $row) &#123;</span><br><span class="line">            foreach ($sortOption as $key &#x3D;&gt; $sortOrder) &#123;</span><br><span class="line">                $data[$key][$index] &#x3D; $row[$key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $args &#x3D; [];</span><br><span class="line">        foreach ($sortOption as $key &#x3D;&gt; $sortOrder) &#123;</span><br><span class="line">            $args[] &#x3D; $data[$key];</span><br><span class="line">            $args[] &#x3D; $sortOrder;</span><br><span class="line">        &#125;</span><br><span class="line">        $args[] &#x3D; &amp;$arr;</span><br><span class="line">        call_user_func_array(&#39;array_multisort&#39;, $args);</span><br><span class="line">        return array_pop($args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>SimplePHP: 实现一个简单的PHP框架</title>
    <url>/2020/01/13/PHP/SimplePHP-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PHP%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h4 id="项目地址-SimplePHP-一个简单PHP框架的实现"><a href="#项目地址-SimplePHP-一个简单PHP框架的实现" class="headerlink" title="项目地址: SimplePHP: 一个简单PHP框架的实现"></a>项目地址: <a href="https://github.com/Wuyiwai/SimplePHP" target="_blank" rel="noopener">SimplePHP</a>: 一个简单PHP框架的实现</h4><a id="more"></a>

<ol>
<li>目的: 简单的实现一个小的可用的PHP框架,来帮助自己更好的理解框架</li>
<li>开发步骤:<ol>
<li>01-搭建基础</li>
<li>02-Application的处理</li>
<li>03-Controller基类</li>
<li>04-实现Model</li>
<li>05-实现RedisCache</li>
<li>06-实现简单FileCache</li>
<li>07-总结</li>
</ol>
</li>
</ol>
<ul>
<li>文档<ol>
<li><a href="https://github.com/Wuyiwai/SimplePHP/blob/master/doc/01-%E6%90%AD%E5%BB%BA%E5%9F%BA%E7%A1%80.md" target="_blank" rel="noopener">01-搭建基础</a></li>
<li><a href="https://github.com/Wuyiwai/SimplePHP/blob/master/doc/02-Application%E7%9A%84%E5%A4%84%E7%90%86.md" target="_blank" rel="noopener">02-Application的处理</a></li>
<li><a href="https://github.com/Wuyiwai/SimplePHP/blob/master/doc/03-Controller%E5%9F%BA%E7%B1%BB.md" target="_blank" rel="noopener">03-Controller基类</a></li>
<li><a href="https://github.com/Wuyiwai/SimplePHP/blob/master/doc/04-%E5%AE%9E%E7%8E%B0Model.md" target="_blank" rel="noopener">04-实现Model</a></li>
<li><a href="https://github.com/Wuyiwai/SimplePHP/blob/master/doc/05-%E5%AE%9E%E7%8E%B0RedisCache.md" target="_blank" rel="noopener">05-实现RedisCache</a></li>
<li><a href="https://github.com/Wuyiwai/SimplePHP/blob/master/doc/06-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95FileCache.md" target="_blank" rel="noopener">06-实现简单FileCache</a></li>
<li><a href="https://github.com/Wuyiwai/SimplePHP/blob/master/doc/07-%E6%80%BB%E7%BB%93.md" target="_blank" rel="noopener">07-总结</a></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下安装nginx,配置php-fpm踩坑</title>
    <url>/2019/12/04/PHP/mac%E4%B8%8B%E5%AE%89%E8%A3%85nginx-%E9%85%8D%E7%BD%AEphp-fpm%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<blockquote>
<p>参考文章</p>
<ol>
<li><a href="https://www.jianshu.com/p/026d67cc6cb1" target="_blank" rel="noopener">brew安装nginx</a></li>
<li><a href="https://blog.csdn.net/darthas/article/details/53980644" target="_blank" rel="noopener">解决mac下自带php-fpm和brew安装的php-fpm的冲突</a></li>
</ol>
</blockquote>
<a id="more"></a>

<h5 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h5><p>通过<code>brew</code>安装nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install nginx</span><br><span class="line">brew services start nginx</span><br><span class="line">访问: http:&#x2F;&#x2F;localhost:8080</span><br></pre></td></tr></table></figure>

<p>nginx常用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx  #启动nginx</span><br><span class="line">nginx -s quit  #快速停止nginx</span><br><span class="line">nginx -V #查看版本，以及配置文件地址</span><br><span class="line">nginx -v #查看版本</span><br><span class="line">nginx -s reload|reopen|stop|quit   #重新加载配置|重启|快速停止|安全关闭nginx</span><br><span class="line">nginx -h #帮助</span><br></pre></td></tr></table></figure>

<ol>
<li>nginx文件目录<ol>
<li>nginx安装文件目录<ol>
<li>/usr/local/Cellar/nginx</li>
</ol>
</li>
<li>nginx配置文件目录<ol>
<li>/usr/local/etc/nginx</li>
</ol>
</li>
<li>config文件目录<ol>
<li>/usr/local/etc/nginx/nginx.conf</li>
</ol>
</li>
</ol>
</li>
</ol>
<h5 id="配置php-fpm"><a href="#配置php-fpm" class="headerlink" title="配置php-fpm"></a>配置php-fpm</h5><ol>
<li>mac下默认自带了php和php-fpm,那么在使用的时候会产生一些冲突<ol>
<li>系统自带的php-fpm在/usr/sbin目录下，</li>
<li>通过brew安装的php中php-fpm在/usr/local/sbin目录，</li>
<li>默认启动PHP-fpm时系统会找到/usr/sbin目录的文件，他的默认php-fpm.conf为/private/etc目录，默认上不存在的,所以会报错导致无法启动</li>
</ol>
</li>
</ol>
<p>解决办法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">把&#x2F;usr&#x2F;local&#x2F;sbin目录加入环境变量最前面，覆盖系统的自带设置</span><br><span class="line">vim ~&#x2F;.bashrc</span><br><span class="line">输入export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:$PATH</span><br><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ENV</category>
      </categories>
      <tags>
        <tag>ENV</tag>
      </tags>
  </entry>
  <entry>
    <title>strtotime踩坑</title>
    <url>/2019/11/25/PHP/strtotime%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<blockquote>
<p>参考文章:</p>
<ol>
<li><a href="http://www.laruence.com/2018/07/31/3207.html" target="_blank" rel="noopener">风雪之隅-令人困惑的strtotime</a></li>
</ol>
</blockquote>
<h6 id="1-month-1-month踩坑"><a href="#1-month-1-month踩坑" class="headerlink" title="+1 month / -1 month踩坑"></a>+1 month / -1 month踩坑</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &quot;[2018-07-31经过(-1 month)之后是:]----&quot; , date(&quot;Y-m-d&quot;,strtotime(&quot;-1 month&quot;, strtotime(&#39;2018-07-31&#39;))) . PHP_EOL;</span><br><span class="line">&#x2F;&#x2F;输出: 2018-07-01</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>此时逻辑是:</p>
<ol>
<li>2018-7-31 减去一个月 变成 2018-6-31</li>
<li>但是6月没有31天,6月最长是30天</li>
<li>所以顺延一天,6.31 = 7.1</li>
</ol>
<p>我们可以做个实验证明上面的逻辑.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;[2017-06-31经过strtotime之后是:]----&quot; , date(&quot;Y-m-d&quot;, strtotime(&quot;2017-06-31&quot;)) . PHP_EOL;</span><br><span class="line">&#x2F;&#x2F;输出: 2018-07-01</span><br></pre></td></tr></table></figure>

<p>同理,只要遇到月尾的时候+1 或者 -1 month,不是实际存在的日期都会发生进退,如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var_dump(date(&quot;Y-m-d&quot;, strtotime(&quot;-1 month&quot;, strtotime(&quot;2017-03-31&quot;))));</span><br><span class="line">&#x2F;&#x2F;输出2017-03-03</span><br><span class="line">var_dump(date(&quot;Y-m-d&quot;, strtotime(&quot;+1 month&quot;, strtotime(&quot;2017-08-31&quot;))));</span><br><span class="line">&#x2F;&#x2F;输出2017-10-01</span><br><span class="line">var_dump(date(&quot;Y-m-d&quot;, strtotime(&quot;next month&quot;, strtotime(&quot;2017-01-31&quot;))));</span><br><span class="line">&#x2F;&#x2F;输出2017-03-03</span><br><span class="line">var_dump(date(&quot;Y-m-d&quot;, strtotime(&quot;last month&quot;, strtotime(&quot;2017-03-31&quot;))));</span><br><span class="line">&#x2F;&#x2F;输出2017-03-03</span><br></pre></td></tr></table></figure>

<p>那么该如何避免: PHP 5.3以后可以使用 “==first day of==” 和 “==last day of==”等修饰词</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var_dump(date(&quot;Y-m-d&quot;, strtotime(&quot;last day of -1 month&quot;, strtotime(&quot;2017-03-31&quot;))));</span><br><span class="line">&#x2F;&#x2F;输出2017-02-28</span><br><span class="line">var_dump(date(&quot;Y-m-d&quot;, strtotime(&quot;first day of +1 month&quot;, strtotime(&quot;2017-08-31&quot;))));</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;输出2017-09-01</span><br><span class="line">var_dump(date(&quot;Y-m-d&quot;, strtotime(&quot;first day of next month&quot;, strtotime(&quot;2017-01-31&quot;))));</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;输出2017-02-01</span><br><span class="line">var_dump(date(&quot;Y-m-d&quot;, strtotime(&quot;last day of last month&quot;, strtotime(&quot;2017-03-31&quot;))));</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;输出2017-02-28</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次复杂的业务需求</title>
    <url>/2019/09/22/PHP/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%A4%8D%E6%9D%82%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%9C%80%E6%B1%82/</url>
    <content><![CDATA[<h3 id="记录一次比较复杂的需求思考过程-异构数据库多表联系-如何将业务联系起来"><a href="#记录一次比较复杂的需求思考过程-异构数据库多表联系-如何将业务联系起来" class="headerlink" title="记录一次比较复杂的需求思考过程,异构数据库多表联系,如何将业务联系起来"></a>记录一次比较复杂的需求思考过程,异构数据库多表联系,如何将业务联系起来</h3><h5 id="主要需求-支持邮件出列表时区分客户和非客户邮件"><a href="#主要需求-支持邮件出列表时区分客户和非客户邮件" class="headerlink" title="主要需求:支持邮件出列表时区分客户和非客户邮件"></a>主要需求:支持邮件出列表时区分客户和非客户邮件</h5><p>邮件列表支持全部邮件、客户、其他的切换，tab标明未读数，默认展示全部邮件tab</p>
<h5 id="现有技术支持"><a href="#现有技术支持" class="headerlink" title="现有技术支持:"></a>现有技术支持:</h5><p>邮件出列表由es出<code>mail_id</code>,而es没有维护邮件和客户的关系,所以只能出<code>mail_id</code>后,在PHP代码中维护<strong>区分客户邮件</strong>这个逻辑.</p>
<h5 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h5><ol>
<li>库异构,所以不能随意join</li>
<li>表关联不紧密</li>
</ol>
<p>有以下几张表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tbl_mail(mail_id,sender,receiver,bcc,cc)</span><br><span class="line"></span><br><span class="line">tbl_company(company_id)</span><br><span class="line"></span><br><span class="line">tbl_customer(customer_id,client_id,email,company_id)</span><br></pre></td></tr></table></figure>
<p>正常来说,应该先根据<code>tbl_mail</code>表中的<code>sender</code>等邮箱,去<code>tbl_customer</code>表找到对应的customer,如果<code>tbl_customer</code>表中<code>company_id</code>不为空(或者更严谨一些,再去<code>tbl_company</code>表中找<code>enable_flag</code>=1的记录),则认为该<code>mail_id</code>为有效的客户邮件.再经过formatter等class去做一些业务逻辑处理数据返回给前端.</p>
]]></content>
      <categories>
        <category>PHP</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下安装xdebug</title>
    <url>/2019/09/18/PHP/mac%E4%B8%8B%E5%AE%89%E8%A3%85xdebug/</url>
    <content><![CDATA[<blockquote>
<p>参考文章</p>
<ol>
<li><a href="https://xdebug.org/docs/install" target="_blank" rel="noopener">Xdebug-install</a></li>
</ol>
</blockquote>
<a id="more"></a>

<h5 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. pecl安装</span><br><span class="line">$ pecl install xdebug</span><br><span class="line">此步骤结尾处会输出:</span><br><span class="line"># Build process completed successfully</span><br><span class="line"># Installing &#39;&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;php&#x2F;7.3.9&#x2F;pecl&#x2F;20180731&#x2F;xdebug.so&#39;</span><br><span class="line"># install ok: channel:&#x2F;&#x2F;pecl.php.net&#x2F;xdebug-2.7.2</span><br><span class="line"># Extension xdebug enabled in php.ini</span><br><span class="line"></span><br><span class="line">2. 查看是否安装成功</span><br><span class="line">$ php -m</span><br><span class="line"></span><br><span class="line">如果输出</span><br><span class="line"># [Zend Modules]</span><br><span class="line"># Xdebug</span><br><span class="line"># Zend OPcache</span><br><span class="line">则安装成功</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PHP</category>
        <category>Xdebug</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Xdebug</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL在一个查询里做两次group by</title>
    <url>/2020/03/19/SQL/MySQL%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E9%87%8C%E5%81%9A%E4%B8%A4%E6%AC%A1group-by/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://segmentfault.com/q/1010000019322585" target="_blank" rel="noopener">参考来源</a></p>
</blockquote>
<p>原始的语句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT email_id,count(1) as c FROM tbl_email_relation WHERE mail_id IN (xxx,xxx) AND customer_id !&#x3D; 0 and email_id &#x3D; 3312172 GROUP BY email_id</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>出来的数据是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">email_id | c |</span><br><span class="line">111 | 4 |</span><br></pre></td></tr></table></figure>

<p>实际上对应的原始数据是这样的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">email_id | mail_id |</span><br><span class="line">111 | 111111 |</span><br><span class="line">111 | 222222 |</span><br><span class="line">111 | 222222 |</span><br><span class="line">111 | 222222 |</span><br></pre></td></tr></table></figure>

<p>而我们希望的数据是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">email_id | c |</span><br><span class="line">111 | 2 |</span><br></pre></td></tr></table></figure>

<p>也就是说希望对mail_id进行二次排序</p>
<p>那么可以这样写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT email_id,count(DISTINCT mail_id) FROM tbl_email_relation WHERE mail_id IN (xxx,xxx) AND customer_id !&#x3D; 0 and email_id &#x3D; 3312172 GROUP BY email_id</span><br></pre></td></tr></table></figure>

<p>出来的数据就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">email_id | c |</span><br><span class="line">111 | 2 |</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次处理分析日志文件的过程</title>
    <url>/2019/10/15/PHP/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><ol>
<li>grep出日志,导出文件</li>
<li>下载到本地</li>
<li>再做正则匹配</li>
</ol>
<a id="more"></a>

<h5 id="要点"><a href="#要点" class="headerlink" title="要点:"></a>要点:</h5><ol>
<li>查找结果导出到ret_log<ol>
<li><code>cat &quot;test_log&quot; | grep &quot;keyword&quot; &gt; ret_log</code></li>
</ol>
</li>
<li>查找结果追加到ret_log<ol>
<li><code>cat &quot;test2_log&quot; | grep &quot;keyword&quot; &gt;&gt; ret_log</code></li>
</ol>
</li>
<li>下载到本地<ol>
<li><code>scp -P 22 root@xxx.xxx.xxx.xxx:/data/web/ret_log /User/wuyiwai/web/</code></li>
</ol>
</li>
<li>本地做正则匹配<ol>
<li>零宽断言 <code>(?&lt;=keyword1).+(?=keyword2)</code> 匹配keyword1到keyword2之间的字符串</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习</title>
    <url>/2019/09/12/SQL/MySQL%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h5 id="唯一索引和普通索引的选择。"><a href="#唯一索引和普通索引的选择。" class="headerlink" title="唯一索引和普通索引的选择。"></a>唯一索引和普通索引的选择。</h5><ol>
<li>因为唯一索引用不上change buffer（节省随机读磁盘的IO消耗），所以更推荐普通索引</li>
<li>问题：change buffer一开始是写内存的，这个时候掉电重启，会不会导致change buffer丢失。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    这个问题的答案是不会丢失。虽然是只更新内存，但是在事务提交的时候，我们</span><br><span class="line">把change buffer的操作也记录到redo log⾥了，所以崩溃恢复的时候，change buffer也能找回来。</span><br></pre></td></tr></table></figure>
<h5 id="MySQL为什么会选错索引导致查询慢？"><a href="#MySQL为什么会选错索引导致查询慢？" class="headerlink" title="MySQL为什么会选错索引导致查询慢？"></a>MySQL为什么会选错索引导致查询慢？</h5></li>
<li>可能是由于删除和插入导致索引统计信息不准确。可以用analyze table来纠正</li>
<li>也可能是优化器误判，这个时候可以在sql中用force index来强行指定索引。</li>
</ol>
<h5 id="怎么给字符串加索引"><a href="#怎么给字符串加索引" class="headerlink" title="怎么给字符串加索引"></a>怎么给字符串加索引</h5><ol>
<li>直接创建完整索引，这样可能⽐较占⽤空间；</li>
<li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使⽤覆盖索引；</li>
<li>倒序存储，再创建前缀索引，⽤于绕过字符串本⾝前缀的区分度不够的问题；</li>
<li>创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种⽅式⼀样，都不⽀持范围扫描。</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>批量合并Update SQL</title>
    <url>/2019/09/02/SQL/%E6%89%B9%E9%87%8F%E5%90%88%E5%B9%B6Update-SQL/</url>
    <content><![CDATA[<p>PHP场景中对于批量update sql拼装成一句sql来减少请求次数的做法</p>
<a id="more"></a>

<h3 id="单条Update-SQL"><a href="#单条Update-SQL" class="headerlink" title="单条Update SQL"></a>单条Update SQL</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE table SET field &#x3D; &#39;value&#39; WHERE other_field &#x3D; &#39;other_value&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="多条Update-SQL合并"><a href="#多条Update-SQL合并" class="headerlink" title="多条Update SQL合并;"></a>多条Update SQL合并;</h3><h5 id="单值多where更改"><a href="#单值多where更改" class="headerlink" title="单值多where更改"></a>单值多where更改</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE table_name </span><br><span class="line">SET field &#x3D; CASE id </span><br><span class="line">    WHEN 1 THEN &#39;value&#39;</span><br><span class="line">    WHEN 2 THEN &#39;value&#39;</span><br><span class="line">    WHEN 3 THEN &#39;value&#39;</span><br><span class="line">END</span><br><span class="line">WHERE id IN (1,2,3)</span><br></pre></td></tr></table></figure>

<ol>
<li>case 后接要比对的条件字段.</li>
<li>如上,即当id=1时,set field = value;当id=2时,set field = value;</li>
<li>where的部分不影响代码的执行,但是会提高sql执行的效率,确保sql语句只执行需要执行的行数.<h5 id="更新多值的"><a href="#更新多值的" class="headerlink" title="更新多值的"></a>更新多值的</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE categories </span><br><span class="line">SET display_order &#x3D; CASE id </span><br><span class="line">    WHEN 1 THEN 3 </span><br><span class="line">    WHEN 2 THEN 4 </span><br><span class="line">    WHEN 3 THEN 5 </span><br><span class="line">END, </span><br><span class="line">title &#x3D; CASE id </span><br><span class="line">    WHEN 1 THEN &#39;New Title 1&#39;</span><br><span class="line">    WHEN 2 THEN &#39;New Title 2&#39;</span><br><span class="line">    WHEN 3 THEN &#39;New Title 3&#39;</span><br><span class="line">END</span><br><span class="line">WHERE id IN (1,2,3)</span><br></pre></td></tr></table></figure>
<h5 id="业务中使用"><a href="#业务中使用" class="headerlink" title="业务中使用"></a>业务中使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$display_order &#x3D; array( </span><br><span class="line">  1 &#x3D;&gt; 4, </span><br><span class="line">  2 &#x3D;&gt; 1, </span><br><span class="line">  3 &#x3D;&gt; 2, </span><br><span class="line">  4 &#x3D;&gt; 3, </span><br><span class="line">  5 &#x3D;&gt; 9, </span><br><span class="line">  6 &#x3D;&gt; 5, </span><br><span class="line">  7 &#x3D;&gt; 8, </span><br><span class="line">  8 &#x3D;&gt; 9 </span><br><span class="line">); </span><br><span class="line">$ids &#x3D; implode(&#39;,&#39;, array_keys($display_order)); </span><br><span class="line">$sql &#x3D; &quot;UPDATE categories SET display_order &#x3D; CASE id &quot;; </span><br><span class="line">foreach ($display_order as $id &#x3D;&gt; $ordinal) &#123; </span><br><span class="line">  $sql .&#x3D; sprintf(&quot;WHEN %d THEN %d &quot;, $id, $ordinal); </span><br><span class="line">&#125; </span><br><span class="line">$sql .&#x3D; &quot;END WHERE id IN ($ids)&quot;; </span><br><span class="line">echo $sql;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql Explain详解</title>
    <url>/2020/05/28/SQL/Mysql-Explain%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>概要: 详细解释Mysql Explain执行计划</p>
</blockquote>
<a id="more"></a>

<table>
<thead>
<tr>
<th align="center">key</th>
<th align="center">value</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td align="center">id</td>
<td align="center">表示查询中执行select子句或者操作表的顺序</td>
<td>id越大,执行优先级越高;id相同,按优化器给出顺序从上往下执行</td>
</tr>
<tr>
<td align="center">select_type</td>
<td align="center">表示 select 查询的类型</td>
<td>-</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">SIMPLE</td>
<td>简单查询,不含子查询或union等操作</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">PRIMARY</td>
<td>含有任何复杂的字部分则标记为PRIMARY</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">SUBQUERY</td>
<td>含有子查询</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">DERIVED</td>
<td>包含在from子句中的子查询的select</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">UNION</td>
<td>union后面又出现select;若union包含在from子句的子查询,外层select会被标记为DERIVED</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">UNION RESULT</td>
<td>代表从union的临时表中读取数据,如果table列数值如&lt;union1,4&gt;,代表用id=1 和 id=4 的结果进行union操作</td>
</tr>
<tr>
<td align="center">table</td>
<td align="center">查询的表名</td>
<td>-</td>
</tr>
<tr>
<td align="center">partitions</td>
<td align="center">匹配到的分区信息</td>
<td>非分区值为NULL</td>
</tr>
<tr>
<td align="center">type</td>
<td align="center">单表的访问方法</td>
<td>性能: system &gt; const &gt; eq_ref &gt; ref &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">system</td>
<td>当表仅有一行记录时(系统表)，数据量很少，往往不需要进行磁盘IO，速度非常快</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">const</td>
<td>表示查询时命中 primary key 主键或者 unique 唯一索引，或者被连接的部分是一个常量(const)值。这类扫描效率极高，返回数据量少，速度非常快。</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">eq_ref</td>
<td>查询时命中主键primary key 或者 unique key索引</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">ref</td>
<td>区别于eq_ref ，ref表示使用非唯一性索引，会找到很多个符合条件的行</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">ref_or_null</td>
<td>这种连接类型类似于 ref，区别在于 MySQL会额外搜索包含NULL值的行</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">index_merge</td>
<td>使用了索引合并优化方法，查询使用了两个以上的索引。</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">unique_subquery</td>
<td>对于以下形式的某些IN子查询，此类型替换eq_ref <br> <code>value IN (SELECT primary_key FROM single_table WHERE some_expr)</code> <br> unique_subquery只是一个索引查找 function，完全替换子查询以提高效率。</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">index_subquery</td>
<td>此连接类型与unique_subquery类似。它取代了IN子查询，但它适用于以下形式的子查询中的非唯一索引：<br> <code>value IN (SELECT key_column FROM single_table WHERE some_expr)</code></td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">range</td>
<td>使用索引选择行，仅检索给定范围内的行. 简单点说就是针对一个有索引的字段，给定范围检索数据。在where语句中使用 bettween…and、&lt;、&gt;、&lt;=、in 等条件查询 type 都是 range。</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">index</td>
<td>Index 与ALL 其实都是读全表，区别在于index是遍历索引树读取，而ALL是从硬盘中读取。</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">ALL</td>
<td>将遍历全表以找到匹配的行，性能最差。</td>
</tr>
<tr>
<td align="center">possible_keys</td>
<td align="center">-</td>
<td>表示在MySQL中通过哪些索引，能让我们在表中找到想要的记录，一旦查询涉及到的某个字段上存在索引，则索引将被列出，但这个索引并不定一会是最终查询数据时所被用到的索引。</td>
</tr>
<tr>
<td align="center">key</td>
<td align="center">区别于possible_keys，key是查询中实际使用到的索引，若没有使用索引，显示为NULL</td>
<td>当 type 为 index_merge 时，可能会显示多个索引。</td>
</tr>
<tr>
<td align="center">key_len</td>
<td align="center">表示查询用到的索引长度（字节数），原则上长度越短越好 。</td>
<td>单列索引，那么需要将整个索引长度算进去； <br> 多列索引，不是所有列都能用到，需要计算查询中实际用到的列。<br> 注意：key_len只计算where条件中用到的索引长度，而排序和分组即便是用到了索引，也不会计算到key_len中。</td>
</tr>
<tr>
<td align="center">ref</td>
<td align="center">-</td>
<td>-</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">const</td>
<td>当使用常量等值查询，显示const</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">字段名</td>
<td>当关联查询时，会显示相应关联表的关联字段</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">func</td>
<td>如果查询条件使用了表达式、函数，或者条件列发生内部隐式转换，可能显示为func</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">null</td>
<td>其他情况</td>
</tr>
<tr>
<td align="center">rows</td>
<td align="center">行数</td>
<td>以表的统计信息和索引使用情况，估算要找到我们所需的记录，需要读取的行数(越小越好)</td>
</tr>
<tr>
<td align="center">filtered</td>
<td align="center">百分比值</td>
<td>表示表里符合条件的记录数的百分比;在MySQL.5.7版本以前想要显示filtered需要使用explain extended命令。MySQL.5.7后，默认explain直接显示partitions和filtered的信息。</td>
</tr>
<tr>
<td align="center">Extra</td>
<td align="center">不适合在其他列中显示的信息</td>
<td>一些额外描述</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">Using index</td>
<td>我们在相应的 select 操作中使用了覆盖索引，通俗一点讲就是查询的列被索引覆盖，使用到覆盖索引查询速度会非常快，SQl优化中理想的状态</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">Using where</td>
<td>查询时未找到可用的索引，进而通过where条件过滤获取所需数据，但要注意的是并不是所有带where语句的查询都会显示Using where</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">Using temporary</td>
<td>表示查询后结果需要使用临时表来存储，一般在排序或者分组查询时用到</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">Using filesort</td>
<td>表示无法利用索引完成的排序操作，也就是ORDER BY的字段没有索引，通常这样的SQL都是需要优化的</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">Using join buffer</td>
<td>在我们联表查询的时候，如果表的连接条件没有用到索引，需要有一个连接缓冲区来存储中间结果</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">Impossible where</td>
<td>表示在我们用不太正确的where语句，导致没有符合条件的行。</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">No tables used</td>
<td>我们的查询语句中没有FROM子句，或者有 FROM DUAL子句</td>
</tr>
</tbody></table>
<blockquote>
<p>参考来源</p>
</blockquote>
<ul>
<li><a href="https://juejin.im/post/5ec4e4a5e51d45786973b357" target="_blank" rel="noopener">不会看 Explain执行计划，劝你简历别写熟悉 SQL优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html" target="_blank" rel="noopener">MySQL官方文档-explain-output</a></li>
<li><a href="https://www.docs4dev.com/docs/zh/mysql/5.7/reference/explain-output.html#jointype_index_subquery" target="_blank" rel="noopener">MySQL5.7中文文档</a></li>
<li><a href="https://mp.weixin.qq.com/s/rem7Ds_QSnyhlrtNPByQcg" target="_blank" rel="noopener">一本彻底搞懂MySQL索引优化EXPLAIN百科全书</a></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PgSQL批量操作update语句</title>
    <url>/2019/10/09/SQL/PgSQL%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9Cupdate%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<blockquote>
<p>参考链接</p>
<ol>
<li><a href="https://stackoverflow.com/questions/18797608/update-multiple-rows-in-same-query-using-postgresql" target="_blank" rel="noopener">stackoverflow</a></li>
</ol>
</blockquote>
<h5 id="想要达到的效果-合并对同一个表的多次update操作"><a href="#想要达到的效果-合并对同一个表的多次update操作" class="headerlink" title="想要达到的效果,合并对同一个表的多次update操作"></a>想要达到的效果,合并对同一个表的多次update操作</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类似于</span><br><span class="line">UPDATE table </span><br><span class="line">SET </span><br><span class="line"> column_a &#x3D; 1 where column_b &#x3D; &#39;123&#39;,</span><br><span class="line"> column_a &#x3D; 2 where column_b &#x3D; &#39;345&#39;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h5 id="更新单列"><a href="#更新单列" class="headerlink" title="更新单列"></a>更新单列</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update test as t set</span><br><span class="line">    column_a &#x3D; c.column_a</span><br><span class="line">from (values</span><br><span class="line">    (&#39;123&#39;, 1),</span><br><span class="line">    (&#39;345&#39;, 2)  </span><br><span class="line">) as c(column_b, column_a) </span><br><span class="line">where c.column_b &#x3D; t.column_b;</span><br></pre></td></tr></table></figure>

<h5 id="更新多列"><a href="#更新多列" class="headerlink" title="更新多列"></a>更新多列</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update test as t set</span><br><span class="line">    column_a &#x3D; c.column_a,</span><br><span class="line">    column_c &#x3D; c.column_c</span><br><span class="line">from (values</span><br><span class="line">    (&#39;123&#39;, 1, &#39;---&#39;),</span><br><span class="line">    (&#39;345&#39;, 2, &#39;+++&#39;)  </span><br><span class="line">) as c(column_b, column_a, column_c) </span><br><span class="line">where c.column_b &#x3D; t.column_b;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL常见命令</title>
    <url>/2019/10/21/SQL/SQL%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<blockquote>
<p>记录常见的SQL命令</p>
</blockquote>
<a id="more"></a>

<ol>
<li><p>查询表索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySQL</span><br><span class="line">show index from table_name（表名）</span><br><span class="line"></span><br><span class="line">PgSQL</span><br><span class="line">select * from pg_indexes where tablename&#x3D;&#39;tbname&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看表字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySQL</span><br><span class="line">show create table table_name;</span><br><span class="line"></span><br><span class="line">PgSQL</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>brew update无响应</title>
    <url>/2019/10/10/linux/brew-update%E6%97%A0%E5%93%8D%E5%BA%94/</url>
    <content><![CDATA[<blockquote>
<p>参考文章</p>
<ol>
<li><a href="https://xu3352.github.io/mac/2018/09/06/mac-homebrew-update-slowly" target="_blank" rel="noopener">brew update无响应</a></li>
</ol>
</blockquote>
<a id="more"></a>

<h5 id="更换brew镜像源"><a href="#更换brew镜像源" class="headerlink" title="更换brew镜像源"></a>更换brew镜像源</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入brew主目录</span><br><span class="line">$ cd &#96;brew --repo&#96;</span><br><span class="line"></span><br><span class="line"># 更换镜像</span><br><span class="line">$ git remote set-url origin https:&#x2F;&#x2F;git.coding.net&#x2F;homebrew&#x2F;homebrew.git</span><br><span class="line"></span><br><span class="line"># 测试效果</span><br><span class="line">$ brew update</span><br></pre></td></tr></table></figure>

<h5 id="几个镜像"><a href="#几个镜像" class="headerlink" title="几个镜像:"></a>几个镜像:</h5><ul>
<li><a href="https://git.coding.net/homebrew/homebrew.git" target="_blank" rel="noopener">https://git.coding.net/homebrew/homebrew.git</a> - Coding</li>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git</a> - 清华</li>
<li><a href="https://mirrors.ustc.edu.cn/brew.git" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/brew.git</a> - 中科大</li>
</ul>
<h5 id="切换回官方源："><a href="#切换回官方源：" class="headerlink" title="切换回官方源："></a>切换回官方源：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 重置brew.git</span><br><span class="line">$ cd &quot;$(brew --repo)&quot;</span><br><span class="line">$ git remote set-url origin https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;brew.git</span><br><span class="line"></span><br><span class="line"># 重置homebrew-core：</span><br><span class="line">$ cd &quot;$(brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core&quot;</span><br><span class="line">$ git remote set-url origin https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;homebrew-core.git</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>top命令</title>
    <url>/2019/10/10/linux/top%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<blockquote>
<p>记录top常用使用技巧</p>
</blockquote>
<a id="more"></a>

<ol>
<li><p>按cpu存排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># linux下</span><br><span class="line">$ top</span><br><span class="line">$ 然后按shift p或者直接大写锁定+P</span><br><span class="line"></span><br><span class="line"># mac下</span><br><span class="line">$ top</span><br><span class="line">$ 然后o</span><br><span class="line">$ 然后输入该栏目name,大小写不严格</span><br><span class="line">$ 比如按cpu降序,则是o+CPU</span><br></pre></td></tr></table></figure>
</li>
<li><p>按cpu排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># linux下</span><br><span class="line">$ top</span><br><span class="line">$ 然后按shift m或者直接大写锁定+M</span><br><span class="line"></span><br><span class="line"># mac下</span><br><span class="line">$ top</span><br><span class="line">$ 然后o</span><br><span class="line">$ 然后输入该栏目name,大小写不严格</span><br><span class="line">$ 比如按cpu降序,则是o+mem</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch学习</title>
    <url>/2019/09/26/other/Elasticsearch%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h5 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h5><ul>
<li><a href="http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html" target="_blank" rel="noopener">阮一峰-ES入门教程</a></li>
<li><a href="https://elasticsearch.cn/" target="_blank" rel="noopener">ES中文社区</a></li>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html" target="_blank" rel="noopener">ES权威指南(略老了)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/54384152" target="_blank" rel="noopener">ES快速入门</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/elasticsearch-intro.html" target="_blank" rel="noopener">ES最新文档(英)</a></li>
</ul>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>值得阅读的文章</title>
    <url>/2019/11/13/other/%E5%80%BC%E5%BE%97%E9%98%85%E8%AF%BB%E7%9A%84%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<ol>
<li><a href="https://mp.weixin.qq.com/s/VIkxGIq6l5BeWDsv4hC7rQ" target="_blank" rel="noopener">TIGERB-面向对象设计</a></li>
</ol>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>JetBrains Mono字体安装</title>
    <url>/2020/05/28/other/JetBrains-Mono%E5%AD%97%E4%BD%93%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<p>概要: JetBrains Mono字体在windows下体验较好.此文将介绍配置过程</p>
</blockquote>
<a id="more"></a>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><a href="https://www.jetbrains.com/lp/mono/#how-to-install" target="_blank" rel="noopener">安装</a></h3><ol>
<li><p>In JetBrains IDEs (version &gt; v2019.3.)</p>
<ol>
<li>Preferences/Settings → Editor → Font, and then select JetBrains Mono from the Font dropdown.</li>
</ol>
</li>
<li><p>Another IDE or an older version of a JetBrains IDE</p>
<ol>
<li><p><a href="https://download.jetbrains.com/fonts/JetBrainsMono-1.0.3.zip?_ga=2.54527723.1348071829.1590655334-1221605599.1575428455" target="_blank" rel="noopener">Download font</a></p>
</li>
<li><p>Unzip the archive and install the font:</p>
<ul>
<li><p>MAC: Select all font files in the folder and double-click them. Click the “Install Font” button.</p>
</li>
<li><p>WIN: Select all font files in the folder, right-click any of them, then pick “Install” from the menu.</p>
</li>
<li><p>LINUX: Unpack fonts to ~/.local/share/fonts (or /usr/share/fonts, to install fonts system-wide) and execute fc-cache -f -v</p>
</li>
</ul>
</li>
<li><p>Restart your IDE.</p>
</li>
<li><p>Go to Preferences/Settings → Editor → Font, and pick JetBrains Mono from the Font dropdown.</p>
</li>
</ol>
</li>
</ol>
<h3 id="推荐配置"><a href="#推荐配置" class="headerlink" title="推荐配置"></a>推荐配置</h3><ol>
<li>Size: 13</li>
<li>Line spacing: 1.2</li>
</ol>
]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP垃圾回收机制</title>
    <url>/2019/09/07/PHP/PHP%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>参考文章:</p>
<ol>
<li><a href="https://www.php.net/manual/zh/features.gc.php" target="_blank" rel="noopener">PHP垃圾回收机制</a></li>
</ol>
</blockquote>
<a id="more"></a>

<h4 id="引用计数基本知识"><a href="#引用计数基本知识" class="headerlink" title="引用计数基本知识"></a>引用计数基本知识</h4><p>每个php变量存在一个叫”zval”的变量容器中。一个zval变量容器，除了包含变量的类型和值，还包括两个字节的额外信息。第一个是”is_ref”，是个bool值，用来标识这个变量是否是属于引用集合(reference set)。通过这个字节，php引擎才能把普通变量和引用变量区分开来，由于php允许用户通过使用&amp;来使用自定义引用，zval变量容器中还有一个内部引用计数机制，来优化内存使用。第二个额外字节是”refcount”，用以表示指向这个zval变量容器的变量(也称符号即symbol)个数。所有的符号存在一个符号表中，其中每个符号都有作用域(scope)，那些主脚本(比如：通过浏览器请求的的脚本)和每个函数或者方法也都有作用域。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;zval定义</span><br><span class="line">typedef struct _zval_struct &#123;</span><br><span class="line">    zvalue_value value;</span><br><span class="line">    zend_uint refcount;</span><br><span class="line">    zend_uchar type;</span><br><span class="line">    zend_uchar is_ref;</span><br><span class="line">  &#125; zval;</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;zvalue_value定义</span><br><span class="line">typedef union _zvalue_value &#123;</span><br><span class="line">    long lval;</span><br><span class="line">    double dval;</span><br><span class="line">    struct &#123;</span><br><span class="line">        char *val;</span><br><span class="line">        int len;</span><br><span class="line">    &#125; str;</span><br><span class="line">    HashTable *ht;</span><br><span class="line">    zend_object_value obj;</span><br><span class="line">&#125; zvalue_value;</span><br></pre></td></tr></table></figure>

<p>当一个变量被赋常量值时，就会生成一个zval变量容器，如下例这样：</p>
<h5 id="Example-1-生成一个新的zval容器"><a href="#Example-1-生成一个新的zval容器" class="headerlink" title="Example #1 生成一个新的zval容器"></a>Example #1 生成一个新的zval容器</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a &#x3D; &quot;new string&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>在上例中，新的变量a，是在当前作用域中生成的。并且生成了类型为 string 和值为new string的变量容器。在额外的两个字节信息中，”is_ref”被默认设置为 FALSE，因为没有任何自定义的引用生成。”refcount” 被设定为 1，因为这里只有一个变量使用这个变量容器. 注意到当”refcount”的值是1时，”is_ref”的值总是FALSE. 如果你已经安装了» Xdebug，你能通过调用函数 xdebug_debug_zval()显示”refcount”和”is_ref”的值。</p>
<h5 id="Example-2-显示zval信息"><a href="#Example-2-显示zval信息" class="headerlink" title="Example #2 显示zval信息"></a>Example #2 显示zval信息</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">xdebug_debug_zval(&#39;a&#39;);</span><br><span class="line">?&gt;</span><br><span class="line">输出：</span><br><span class="line">a: (refcount&#x3D;1, is_ref&#x3D;0)&#x3D;&#39;new string&#39;</span><br></pre></td></tr></table></figure>

<p>把一个变量赋值给另一变量将增加引用次数(refcount).</p>
<h5 id="Example-3-增加一个zval的引用计数"><a href="#Example-3-增加一个zval的引用计数" class="headerlink" title="Example #3 增加一个zval的引用计数"></a>Example #3 增加一个zval的引用计数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a &#x3D; &quot;new string&quot;;</span><br><span class="line">$b &#x3D; $a;</span><br><span class="line">xdebug_debug_zval( &#39;a&#39; );</span><br><span class="line">?&gt;</span><br><span class="line">输出：</span><br><span class="line">a: (refcount&#x3D;2, is_ref&#x3D;0)&#x3D;&#39;new string&#39;</span><br></pre></td></tr></table></figure>

<p>这时，引用次数是2，因为同一个变量容器被变量 a 和变量 b关联.当没必要时，php不会去复制已生成的变量容器。变量容器在”refcount“变成0时就被销毁. 当任何关联到某个变量容器的变量离开它的作用域(比如：函数执行结束)，或者对变量调用了函数 unset()时，”refcount“就会减1，下面的例子就能说明:</p>
<h5 id="Example-4-减少引用计数"><a href="#Example-4-减少引用计数" class="headerlink" title="Example #4 减少引用计数"></a>Example #4 减少引用计数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a &#x3D; &quot;new string&quot;;</span><br><span class="line">$c &#x3D; $b &#x3D; $a;</span><br><span class="line">xdebug_debug_zval( &#39;a&#39; );</span><br><span class="line">unset( $b, $c );</span><br><span class="line">xdebug_debug_zval( &#39;a&#39; );</span><br><span class="line">?&gt;</span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">a: (refcount&#x3D;3, is_ref&#x3D;0)&#x3D;&#39;new string&#39;</span><br><span class="line">a: (refcount&#x3D;1, is_ref&#x3D;0)&#x3D;&#39;new string&#39;</span><br></pre></td></tr></table></figure>

<p>如果我们现在执行 unset($a);，包含类型和值的这个变量容器就会从内存中删除。</p>
<p>复合类型(Compound Types)<br>当考虑像 array和object这样的复合类型时，事情就稍微有点复杂. 与 标量(scalar)类型的值不同，array和 object类型的变量把它们的成员或属性存在自己的符号表中。这意味着下面的例子将生成三个zval变量容器。</p>
<h5 id="Example-5-Creating-a-array-zval"><a href="#Example-5-Creating-a-array-zval" class="headerlink" title="Example #5 Creating a array zval"></a>Example #5 Creating a array zval</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a &#x3D; array( &#39;meaning&#39; &#x3D;&gt; &#39;life&#39;, &#39;number&#39; &#x3D;&gt; 42 );</span><br><span class="line">xdebug_debug_zval( &#39;a&#39; );</span><br><span class="line">?&gt;</span><br><span class="line">以上例程的输出类似于：</span><br><span class="line"></span><br><span class="line">a: (refcount&#x3D;1, is_ref&#x3D;0)&#x3D;array (</span><br><span class="line">   &#39;meaning&#39; &#x3D;&gt; (refcount&#x3D;1, is_ref&#x3D;0)&#x3D;&#39;life&#39;,</span><br><span class="line">   &#39;number&#39; &#x3D;&gt; (refcount&#x3D;1, is_ref&#x3D;0)&#x3D;42</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>图示:<br><img src="https://raw.githubusercontent.com/Wuyiwai/Source/master/php-gc-1.png" alt="一个简单数组的zval"></p>
<p>这三个zval变量容器是: a，meaning和 number。增加和减少”refcount”的规则和上面提到的一样. 下面, 我们在数组中再添加一个元素,并且把它的值设为数组中已存在元素的值:</p>
<h5 id="Example-6-添加一个已经存在的元素到数组中"><a href="#Example-6-添加一个已经存在的元素到数组中" class="headerlink" title="Example #6 添加一个已经存在的元素到数组中"></a>Example #6 添加一个已经存在的元素到数组中</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a &#x3D; array( &#39;meaning&#39; &#x3D;&gt; &#39;life&#39;, &#39;number&#39; &#x3D;&gt; 42 );</span><br><span class="line">$a[&#39;life&#39;] &#x3D; $a[&#39;meaning&#39;];</span><br><span class="line">xdebug_debug_zval( &#39;a&#39; );</span><br><span class="line">?&gt;</span><br><span class="line">输出：</span><br><span class="line">a: (refcount&#x3D;1, is_ref&#x3D;0)&#x3D;array (</span><br><span class="line">   &#39;meaning&#39; &#x3D;&gt; (refcount&#x3D;2, is_ref&#x3D;0)&#x3D;&#39;life&#39;,</span><br><span class="line">   &#39;number&#39; &#x3D;&gt; (refcount&#x3D;1, is_ref&#x3D;0)&#x3D;42,</span><br><span class="line">   &#39;life&#39; &#x3D;&gt; (refcount&#x3D;2, is_ref&#x3D;0)&#x3D;&#39;life&#39;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>图示：<br><img src="https://raw.githubusercontent.com/Wuyiwai/Source/master/php-gc-2.png" alt="带有引用的简单数组的zval"></p>
<p>从以上的xdebug输出信息，我们看到原有的数组元素和新添加的数组元素关联到同一个”refcount”2的zval变量容器. 尽管 Xdebug的输出显示两个值为’life’的 zval 变量容器，其实是同一个。 函数xdebug_debug_zval()不显示这个信息，但是你能通过显示内存指针信息来看到。</p>
<p>删除数组中的一个元素，就是类似于从作用域中删除一个变量. 删除后,数组中的这个元素所在的容器的“refcount”值减少，同样，当“refcount”为0时，这个变量容器就从内存中被删除，下面又一个例子可以说明：</p>
<h5 id="Example-7-从数组中删除一个元素"><a href="#Example-7-从数组中删除一个元素" class="headerlink" title="Example #7 从数组中删除一个元素"></a>Example #7 从数组中删除一个元素</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a &#x3D; array( &#39;meaning&#39; &#x3D;&gt; &#39;life&#39;, &#39;number&#39; &#x3D;&gt; 42 );</span><br><span class="line">$a[&#39;life&#39;] &#x3D; $a[&#39;meaning&#39;];</span><br><span class="line">unset( $a[&#39;meaning&#39;], $a[&#39;number&#39;] );</span><br><span class="line">xdebug_debug_zval( &#39;a&#39; );</span><br><span class="line">?&gt;</span><br><span class="line">以上例程的输出类似于：</span><br><span class="line"></span><br><span class="line">a: (refcount&#x3D;1, is_ref&#x3D;0)&#x3D;array (</span><br><span class="line">   &#39;life&#39; &#x3D;&gt; (refcount&#x3D;1, is_ref&#x3D;0)&#x3D;&#39;life&#39;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>现在，当我们添加一个数组本身作为这个数组的元素时，事情就变得有趣，下个例子将说明这个。例中我们加入了引用操作符，否则php将生成一个复制。</p>
<h5 id="Example-8-把数组作为一个元素添加到自己"><a href="#Example-8-把数组作为一个元素添加到自己" class="headerlink" title="Example #8 把数组作为一个元素添加到自己"></a>Example #8 把数组作为一个元素添加到自己</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a &#x3D; array( &#39;one&#39; );</span><br><span class="line">$a[] &#x3D;&amp; $a;</span><br><span class="line">xdebug_debug_zval( &#39;a&#39; );</span><br><span class="line">?&gt;</span><br><span class="line">以上例程的输出类似于：</span><br><span class="line"></span><br><span class="line">a: (refcount&#x3D;2, is_ref&#x3D;1)&#x3D;array (</span><br><span class="line">   0 &#x3D;&gt; (refcount&#x3D;1, is_ref&#x3D;0)&#x3D;&#39;one&#39;,</span><br><span class="line">   1 &#x3D;&gt; (refcount&#x3D;2, is_ref&#x3D;1)&#x3D;...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>图示：<br><img src="https://raw.githubusercontent.com/Wuyiwai/Source/master/php-gc-3.png" alt="自引用(curcular reference,自己是自己的一个元素)的数组的zval"></p>
<p>能看到数组变量 (a) 同时也是这个数组的第二个元素(1) 指向的变量容器中“refcount”为 2。上面的输出结果中的”…”说明发生了递归操作, 显然在这种情况下意味着”…”指向原始数组。</p>
<p>跟刚刚一样，对一个变量调用unset，将删除这个符号，且它指向的变量容器中的引用次数也减1。所以，如果我们在执行完上面的代码后，对变量$a调用unset, 那么变量 $a 和数组元素 “1” 所指向的变量容器的引用次数减1, 从”2”变成”1”. 下例可以说明:</p>
<h5 id="Example-9-Unsetting-a"><a href="#Example-9-Unsetting-a" class="headerlink" title="Example #9 Unsetting $a"></a>Example #9 Unsetting $a</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(refcount&#x3D;1, is_ref&#x3D;1)&#x3D;array (</span><br><span class="line">   0 &#x3D;&gt; (refcount&#x3D;1, is_ref&#x3D;0)&#x3D;&#39;one&#39;,</span><br><span class="line">   1 &#x3D;&gt; (refcount&#x3D;1, is_ref&#x3D;1)&#x3D;...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>图示：<br><img src="https://raw.githubusercontent.com/Wuyiwai/Source/master/php-gc-4.png" alt="Zvals after removal of array with a circular reference demonstrating the memory leak"></p>
<h4 id="清理变量容器的问题-Cleanup-Problems"><a href="#清理变量容器的问题-Cleanup-Problems" class="headerlink" title="清理变量容器的问题(Cleanup Problems)"></a>清理变量容器的问题(Cleanup Problems)</h4><p>尽管不再有某个作用域中的任何符号指向这个结构(就是变量容器)，由于数组元素“1”仍然指向数组本身，所以这个容器不能被清除 。因为没有另外的符号指向它，用户没有办法清除这个结构，结果就会导致内存泄漏。庆幸的是，php将在脚本执行结束时清除这个数据结构，但是在php清除之前，将耗费不少内存。如果你要实现分析算法，或者要做其他像一个子元素指向它的父元素这样的事情，这种情况就会经常发生。当然，同样的情况也会发生在对象上，实际上对象更有可能出现这种情况，因为对象总是隐式的被引用。</p>
<p>如果上面的情况发生仅仅一两次倒没什么，但是如果出现几千次，甚至几十万次的内存泄漏，这显然是个大问题。这样的问题往往发生在长时间运行的脚本中，比如请求基本上不会结束的守护进程(deamons)或者单元测试中的大的套件(sets)中。后者的例子：在给巨大的eZ(一个知名的PHP Library) 组件库的模板组件做单元测试时，就可能会出现问题。有时测试可能需要耗用2GB的内存，而测试服务器很可能没有这么大的内存。</p>
<h4 id="回收周期-Collecting-Cycles"><a href="#回收周期-Collecting-Cycles" class="headerlink" title="回收周期(Collecting Cycles)"></a>回收周期(Collecting Cycles)</h4><p>传统上，像以前的 php 用到的引用计数内存机制，无法处理循环的引用内存泄漏。然而 5.3.0 PHP 使用文章» <a href="http://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon01Concurrent.pdf" target="_blank" rel="noopener">引用计数系统中的同步周期回收(Concurrent Cycle Collection in Reference Counted Systems)</a>中的同步算法，来处理这个内存泄漏问题。</p>
<p>对算法的完全说明有点超出这部分内容的范围，将只介绍其中基础部分。首先，我们先要建立一些基本规则，如果一个引用计数增加，它将继续被使用，当然就不再在垃圾中。如果引用计数减少到零，所在变量容器将被清除(free)。就是说，仅仅在引用计数减少到非零值时，才会产生垃圾周期(garbage cycle)。其次，在一个垃圾周期中，通过检查引用计数是否减1，并且检查哪些变量容器的引用次数是零，来发现哪部分是垃圾。</p>
<p><img src="https://raw.githubusercontent.com/Wuyiwai/Source/master/php-gc-5.png" alt="垃圾回收算法"></p>
<p>为避免不得不检查所有引用计数可能减少的垃圾周期，这个算法把所有可能根(possible roots 都是zval变量容器),放在根缓冲区(root buffer)中(用紫色来标记，称为疑似垃圾)，这样可以同时确保每个可能的垃圾根(possible garbage root)在缓冲区中只出现一次。仅仅在根缓冲区满了时，才对缓冲区内部所有不同的变量容器执行垃圾回收操作。看上图的步骤 A。</p>
<p>在步骤 B 中，模拟删除每个紫色变量。模拟删除时可能将不是紫色的普通变量引用数减”1”，如果某个普通变量引用计数变成0了，就对这个普通变量再做一次模拟删除。每个变量只能被模拟删除一次，模拟删除后标记为灰（原文说确保不会对同一个变量容器减两次”1”,不对的吧）。</p>
<p>在步骤 C 中，模拟恢复每个紫色变量。恢复是有条件的，当变量的引用计数大于0时才对其做模拟恢复。同样每个变量只能恢复一次，恢复后标记为黑，基本就是步骤 B 的逆运算。这样剩下的一堆没能恢复的就是该删除的蓝色节点了，在步骤 D 中遍历出来真的删除掉。</p>
<p>算法中都是模拟删除、模拟恢复、真的删除，都使用简单的遍历即可（最典型的深搜遍历）。复杂度为执行模拟操作的节点数正相关，不只是紫色的那些疑似垃圾变量。</p>
<p>现在，你已经对这个算法有了基本了解，我们回头来看这个如何与PHP集成。默认的，PHP的垃圾回收机制是打开的，然后有个 php.ini 设置允许你修改它：<strong>zend.enable_gc</strong> 。</p>
<p>当垃圾回收机制打开时，每当根缓存区存满时，就会执行上面描述的循环查找算法。根缓存区有固定的大小，可存10,000个可能根,当然你可以通过修改PHP源码文件Zend/zend_gc.c中的常量GC_ROOT_BUFFER_MAX_ENTRIES，然后重新编译PHP，来修改这个10,000值。当垃圾回收机制关闭时，循环查找算法永不执行，然而，可能根将一直存在根缓冲区中，不管在配置中垃圾回收机制是否激活。</p>
<p>当垃圾回收机制关闭时，如果根缓冲区存满了可能根，更多的可能根显然不会被记录。那些没被记录的可能根，将不会被这个算法来分析处理。如果他们是循环引用周期的一部分，将永不能被清除进而导致内存泄漏。</p>
<p>即使在垃圾回收机制不可用时，可能根也被记录的原因是，相对于每次找到可能根后检查垃圾回收机制是否打开而言，记录可能根的操作更快。不过垃圾回收和分析机制本身要耗不少时间。</p>
<p><strong>除了修改配置zend.enable_gc ，也能通过分别调用gc_enable() 和 gc_disable()函数来打开和关闭垃圾回收机制。调用这些函数，与修改配置项来打开或关闭垃圾回收机制的效果是一样的。即使在可能根缓冲区还没满时，也能强制执行周期回收。你能调用gc_collect_cycles()函数达到这个目的。这个函数将返回使用这个算法回收的周期数。</strong></p>
<p>允许打开和关闭垃圾回收机制并且允许自主的初始化的原因，是由于你的应用程序的某部分可能是高时效性的。在这种情况下，你可能不想使用垃圾回收机制。当然，对你的应用程序的某部分关闭垃圾回收机制，是在冒着可能内存泄漏的风险，因为一些可能根也许存不进有限的根缓冲区。因此，就在你调用gc_disable()函数释放内存之前，先调用gc_collect_cycles()函数可能比较明智。因为这将清除已存放在根缓冲区中的所有可能根，然后在垃圾回收机制被关闭时，可留下空缓冲区以有更多空间存储可能根。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>循环引用造成的内存泄漏<ol>
<li>如果引用计数减少到零，所在变量容器将被清除.</li>
<li>如果一个zval 的引用计数减少后还大于0，那么它会进入垃圾周期。其次，在一个垃圾周期中，通过检查引用计数是否减1，并且检查哪些变量容器的引用次数是零，来发现哪部分是垃圾。</li>
<li>循环引用基本上只会出现在 数组和对象中，对象是因为它的本身就是引用</li>
</ol>
</li>
<li>对象和数组的回收<ol>
<li>垃圾收集器:把变量的zend_refcount信息放到回收池,满了会回收.</li>
<li>垃圾回收算法:<ol>
<li>遍历回收池中的每一个变量，根据每一个变量，再遍历每一个成员，如果成员还有嵌套的话继续遍历。然后把所有成员的 做模拟的 refcount -1。如果此时外部的变量的 引用次数为 0 。那么可以视为垃圾，清楚。如果大于0，那么恢复引用次数，并从垃圾回收池中取出。</li>
<li>原理:如果你这个变量不是垃圾，那么它的所有成员变量的引用减一之后，必然不会是总变量的引用为0。</li>
</ol>
</li>
</ol>
</li>
<li>todo:装个xdebug模拟一下</li>
</ol>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP7的异常处理</title>
    <url>/2019/09/02/PHP/PHP7%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章:"></a>参考文章:</h5><ol>
<li><a href="https://www.php.net/manual/en/class.throwable.php" target="_blank" rel="noopener">PHP Manual-Throwable</a></li>
<li><a href="https://trowski.com/2015/06/24/throwable-exceptions-and-errors-in-php7/" target="_blank" rel="noopener">Throwable Exceptions and Errors in PHP 7</a></li>
<li><a href="https://novnan.github.io/PHP/throwable-exceptions-and-errors-in-php7/" target="_blank" rel="noopener">(转载自)HP7中的异常与错误处理</a></li>
</ol>
</blockquote>
<a id="more"></a>

<h4 id="PHP-中的-Exception-Error-Throwable"><a href="#PHP-中的-Exception-Error-Throwable" class="headerlink" title="PHP 中的 Exception, Error, Throwable"></a>PHP 中的 Exception, Error, Throwable</h4><ul>
<li>PHP 中将代码自身异常(一般是环境或者语法非法所致)称作错误 Error，将运行中出现的逻辑错误称为异常 Exception</li>
<li>错误是没法通过代码处理的，而异常则可以通过 try/catch 来处理</li>
<li>PHP7 中出现了 Throwable 接口，该接口由 Error 和 Exception 实现，用户不能直接实现 Throwable 接口，而只能通过继承 Exception 来实现接口</li>
</ul>
<h4 id="PHP7-异常处理机制"><a href="#PHP7-异常处理机制" class="headerlink" title="PHP7 异常处理机制"></a>PHP7 异常处理机制</h4><p>过去的 PHP，处理致命错误几乎是不可能的。致命错误不会调用由 set_error_handler() 设置的处理方式，而是简单的停止脚本的执行。</p>
<p>在 PHP7 中，当致命错误和可捕获的错误(E_ERROR 和 E_RECOVERABLE_ERROR)发生时会抛出异常，而不是直接停止脚本的运行。对于某些情况，比如内存溢出，致命错误则仍然像之前一样直接停止脚本执行。在 PHP7 中，一个未捕获的异常也会是一个致命错误。这意味着在 PHP5.x 中致命错误抛出的异常未捕获，在 PHP7 中也是致命错误。</p>
<blockquote>
<p>注意：其他级别的错误如 warning 和 notice，和之前一样不会抛出异常，只有 fatal 和 recoverable 级别的错误会抛出异常。</p>
</blockquote>
<p>从 fatal 和 recoverable 级别错误抛出的异常并非继承自 Exception 类。这种分离是为了防止现有 PHP5.x 的用于停止脚本运行的代码也捕获到错误抛出的异常。fatal 和 recoverable 级别的错误抛出的异常是一个全新分离出来的类 Error 类的实例。跟其他异常一样，Error 类异常也能被捕获和处理，同样允许在 finally 之类的块结构中运行。</p>
<h4 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h4><p>为了统一两个异常分支，Exception 和 Error 都实现了一个全新的接口：Throwable</p>
<p>PHP7 中新的异常结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Throwable</span><br><span class="line">    |- Exception implements Throwable</span><br><span class="line">        |- ...</span><br><span class="line">    |- Error implements Throwable</span><br><span class="line">        |- TypeError extends Error</span><br><span class="line">        |- ParseError extends Error</span><br><span class="line">        |- ArithmeticError extends Error</span><br><span class="line">            |- DivisionByZeroError extends ArithmeticError</span><br><span class="line">        |- AssertionError extends Error</span><br></pre></td></tr></table></figure>
<p>如果在 PHP7 的代码中定义了 Throwable 类，它将会是如下这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Throwable</span><br><span class="line">&#123;</span><br><span class="line">public function getMessage(): string;</span><br><span class="line">public function getCode(): int;</span><br><span class="line">public function getFile(): string;</span><br><span class="line">public function getLine(): int;</span><br><span class="line">public function getTrace(): array;</span><br><span class="line">public function getTraceAsString(): string;</span><br><span class="line">public function getPrevious(): Throwable;</span><br><span class="line">public function __toString(): string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口看起来很熟悉。Throwable 规定的方法跟 Exception 几乎是一样的。唯一不同的是 Throwable::getPrevious() 返回的是 Throwable 的实例而不是 Exception 的。Exception 和 Error 的构造函数跟之前 Exception 一样，可以接受任何 Throwable 的实例。<br>Throwable 可以用于 try/catch 块中捕获 Exception 和 Error 对象(或是任何未来可能的异常类型)。记住捕获更多特定类型的异常并且对之做相应的处理是更好的实践。然而在某种情况下我们想捕获任何类型的异常(比如日志或框架中错误处理)。在 PHP7 中，要捕获所有的应该使用 Throwable 而不是 Exception。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F; Code that may throw an Exception or Error.</span><br><span class="line">&#125; catch (Throwable $t) &#123;</span><br><span class="line">&#x2F;&#x2F; Handle exception</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户定义的类不能实现 Throwable 接口。做出这个决定一定程度上是为了预测性和一致性——只有 Exception 和 Error 的对象可以被抛出。此外，异常需要携带对象在追溯堆栈中创建位置的信息，而用户定义的对象不会自动的有参数来存储这些信息。<br>Throwable 可以被继承从而创建特定的包接口或者添加额外的方法。一个继承自 Throwable 的接口只能被 Exception 或 Error 的子类来实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface MyPackageThrowable extends Throwable &#123;&#125;</span><br><span class="line"></span><br><span class="line">class MyPackageException extends Exception implements MyPackageThrowable &#123;&#125;</span><br><span class="line"></span><br><span class="line">throw new MyPackageException();</span><br></pre></td></tr></table></figure>

<h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><p>事实上，PHP5.x 中所有的错误都是 fatal 或 recoverable 级别的错误，在 PHP7 中都能抛出一个 Error 实例。跟其他任何异常一样，Error 对象可以使用 try/catch 块来捕获。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$var &#x3D; 1;</span><br><span class="line">try &#123;</span><br><span class="line">$var-&gt;method(); &#x2F;&#x2F; Throws an Error object in PHP 7.</span><br><span class="line">&#125; catch (Error $e) &#123;</span><br><span class="line">&#x2F;&#x2F; Handle error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下，之前的致命错误都会抛出一个基本的 Error 类实例，但某些错误会抛出一个更具体的 Error 子类：TypeError、ParseError 以及 AssertionError。</p>
<h4 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a>TypeError</h4><p>当函数参数或返回值不符合声明的类型时，TypeError 的实例会被抛出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(int $left, int $right)</span><br><span class="line">&#123;</span><br><span class="line">return $left + $right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">$value &#x3D; add(&#39;left&#39;, &#39;right&#39;);</span><br><span class="line">&#125; catch (TypeError $e) &#123;</span><br><span class="line">echo $e-&gt;getMessage(), &quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Argument 1 passed to add() must be of the type integer, string given</span><br></pre></td></tr></table></figure>

<h4 id="ParseError"><a href="#ParseError" class="headerlink" title="ParseError"></a>ParseError</h4><p>当 include/require 文件或 eval() 代码存在语法错误时，ParseError 会被抛出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">require &#39;file-with-parse-error.php&#39;;</span><br><span class="line">&#125; catch (ParseError $e) &#123;</span><br><span class="line">echo $e-&gt;getMessage(), &quot;\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ArithmeticError"><a href="#ArithmeticError" class="headerlink" title="ArithmeticError"></a>ArithmeticError</h4><p>ArithmeticError 在两种情况下会被抛出。一是位移操作负数位。二是调用 intdiv() 时分子是 PHP_INT_MIN 且分母是 -1 (这个使用除法运算符的表达式：PHP_INT_MIN / -1，结果是浮点型)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">$value &#x3D; 1 &lt;&lt; -1;</span><br><span class="line">catch (ArithmeticError $e) &#123;</span><br><span class="line">echo $e-&gt;getMessage();&#x2F;&#x2F;Bit shift by negative number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DevisionByZeroError"><a href="#DevisionByZeroError" class="headerlink" title="DevisionByZeroError"></a>DevisionByZeroError</h4><p>当 intdiv() 的分母是 0 或者取模操作 (%) 中分母是 0 时，DivisionByZeroError 会被抛出。注意在除法运算符 (/) 中使用 0 作除数（也即xxx/0这样写）时只会触发一个 warning，这时候若分子非零结果是 INF，若分子是 0 结果是 NaN。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">$value &#x3D; 1 % 0;</span><br><span class="line">&#125; catch (DivisionByZeroError $e) &#123;</span><br><span class="line">echo $e-&gt;getMessage();&#x2F;&#x2F;Modulo by zero</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AssertionError"><a href="#AssertionError" class="headerlink" title="AssertionError"></a>AssertionError</h3><p>当 assert() 的条件不满足时，AssertionError 会被抛出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini_set(&#39;zend.assertions&#39;, 1);</span><br><span class="line">ini_set(&#39;assert.exception&#39;, 1);</span><br><span class="line"></span><br><span class="line">$test &#x3D; 1;</span><br><span class="line"></span><br><span class="line">assert($test &#x3D;&#x3D;&#x3D; 0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Fatal error: Uncaught AssertionError: assert($test &#x3D;&#x3D;&#x3D; 0)</span><br></pre></td></tr></table></figure>

<p>只有断言启用并且是设置 ini 配置的 zend.assertions = 1 和 assert.exception = 1 时，assert() 才会执行并抛 AssertionError。</p>
<h4 id="在你的代码中使用-Error"><a href="#在你的代码中使用-Error" class="headerlink" title="在你的代码中使用 Error"></a>在你的代码中使用 Error</h4><p>用户可以通过继承 Error 来创建符合自己层级要求的 Error 类。这就形成了一个问题：什么情况下应该抛出 Exception，什么情况下应该抛出 Error。</p>
<p>Error 应该用来表示需要程序员关注的代码问题。从 PHP 引擎抛出的 Error 对象属于这些分类，通常都是代码级别的错误，比如传递了错误类型的参数给一个函数或者解析一个文件发生错误。Exception 则应该用于在运行时能安全的处理，并且另一个动作能继续执行的情况。</p>
<p>由于 Error 对象不应该在运行时被处理，因此捕获 Error 对象也应该是不频繁的。一般来说，Error 对象仅被捕获用于日志记录、执行必要的清理以及展示错误信息给用户。</p>
<h4 id="编写代码支持-PHP5-x-和-PHP7-的异常"><a href="#编写代码支持-PHP5-x-和-PHP7-的异常" class="headerlink" title="编写代码支持 PHP5.x 和 PHP7 的异常"></a>编写代码支持 PHP5.x 和 PHP7 的异常</h4><p>为了在同样的代码中捕获任何 PHP5.x 和 PHP7 的异常，可以使用多个 catch，先捕获 Throwable，然后是 Exception。当 PHP5.x 不再需要支持时，捕获 Exception 的 catch 块可以移除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F; Code that may throw an Exception or Error.</span><br><span class="line">&#125; catch (Throwable $t) &#123;</span><br><span class="line">&#x2F;&#x2F; Executed only in PHP 7, will not match in PHP 5.x</span><br><span class="line">&#125; catch (Exception $e) &#123;</span><br><span class="line">&#x2F;&#x2F; Executed only in PHP 5.x, will not be reached in PHP 7</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不幸的是，处理异常的函数中的类型声明不容易确定。当 Exception 用于函数参数类型声明时，如果函数调用时候能用 Error 的实例，这个类型声明就要去掉。当 PHP5.x 不需要被支持时，类型声明则可以还原为 Throwable。</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP状态码详解</title>
    <url>/2019/10/29/knowledge/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>参考源</p>
<ol>
<li><a href="http://tool.oschina.net/commons?type=5" target="_blank" rel="noopener">HTTP状态码详解</a></li>
</ol>
</blockquote>
<a id="more"></a>

<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td>
</tr>
<tr>
<td>101</td>
<td>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 　　只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td>
</tr>
<tr>
<td>102</td>
<td>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</td>
</tr>
<tr>
<td>200</td>
<td>请求已成功，请求所希望的响应头或数据体将随此响应返回。</td>
</tr>
<tr>
<td>201</td>
<td>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</td>
</tr>
<tr>
<td>202</td>
<td>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 　　返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td>
</tr>
<tr>
<td>203</td>
<td>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td>
</tr>
<tr>
<td>204</td>
<td>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 　　如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 　　由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td>
</tr>
<tr>
<td>205</td>
<td>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 　　与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td>
</tr>
<tr>
<td>206</td>
<td>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 　　该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 　　响应必须包含如下的头部域： 　　Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 　　Date 　　ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 　　Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 　　假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 　　任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</td>
</tr>
<tr>
<td>207</td>
<td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td>
</tr>
<tr>
<td>300</td>
<td>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 　　除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 　　如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td>
</tr>
<tr>
<td>301</td>
<td>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 　　新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</td>
</tr>
<tr>
<td>302</td>
<td>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td>
</tr>
<tr>
<td>303</td>
<td>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 　　新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td>
</tr>
<tr>
<td>304</td>
<td>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 　　该响应必须包含以下的头信息： 　　Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 　　ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 　　Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 　　假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 　　假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td>
</tr>
<tr>
<td>305</td>
<td>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 　　注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td>
</tr>
<tr>
<td>306</td>
<td>在最新版的规范中，306状态码已经不再被使用。</td>
</tr>
<tr>
<td>307</td>
<td>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 　　如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td>
</tr>
<tr>
<td>400</td>
<td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。               <br>2、请求参数有误。</td>
</tr>
<tr>
<td>401</td>
<td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td>
</tr>
<tr>
<td>402</td>
<td>该状态码是为了将来可能的需求而预留的。</td>
</tr>
<tr>
<td>403</td>
<td>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td>
</tr>
<tr>
<td>404</td>
<td>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td>
</tr>
<tr>
<td>405</td>
<td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 　　鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td>
</tr>
<tr>
<td>406</td>
<td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 　　除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td>
</tr>
<tr>
<td>407</td>
<td>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</td>
</tr>
<tr>
<td>408</td>
<td>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td>
</tr>
<tr>
<td>409</td>
<td>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 　　冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td>
</tr>
<tr>
<td>410</td>
<td>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 　　410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td>
</tr>
<tr>
<td>411</td>
<td>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td>
</tr>
<tr>
<td>412</td>
<td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td>
</tr>
<tr>
<td>413</td>
<td>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 　　如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td>
</tr>
<tr>
<td>414</td>
<td>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 　　本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 　　重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 　　客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td>
</tr>
<tr>
<td>415</td>
<td>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td>
</tr>
<tr>
<td>416</td>
<td>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 　　假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td>
</tr>
<tr>
<td>417</td>
<td>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td>
</tr>
<tr>
<td>421</td>
<td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>
</tr>
<tr>
<td>422</td>
<td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>
</tr>
<tr>
<td>422</td>
<td>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 　　当前资源被锁定。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td>424</td>
<td>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td>425</td>
<td>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</td>
</tr>
<tr>
<td>426</td>
<td>客户端应当切换到TLS/1.0。（RFC 2817）</td>
</tr>
<tr>
<td>449</td>
<td>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td>
</tr>
<tr>
<td>500</td>
<td>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</td>
</tr>
<tr>
<td>501</td>
<td>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td>
</tr>
<tr>
<td>502</td>
<td>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td>
</tr>
<tr>
<td>503</td>
<td>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 　　注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</td>
</tr>
<tr>
<td>504</td>
<td>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 　　注意：某些代理服务器在DNS查询超时时会返回400或者500错误</td>
</tr>
<tr>
<td>505</td>
<td>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td>
</tr>
<tr>
<td>506</td>
<td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td>
</tr>
<tr>
<td>507</td>
<td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td>
</tr>
<tr>
<td>509</td>
<td>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td>
</tr>
<tr>
<td>510</td>
<td>获取资源所需要的策略并没有没满足。（RFC 2774）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划总结</title>
    <url>/2020/04/22/Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h5 id="动态规划是什么"><a href="#动态规划是什么" class="headerlink" title="动态规划是什么"></a>动态规划是什么</h5><p>动态规划的大致思路是把一个复杂的问题转化成一个分阶段逐步递推的过程，从简单的初始状态一步一步递推，最终得到复杂问题的最优解。</p>
<a id="more"></a>

<ul>
<li>一般形式: 求最值</li>
<li>核心问题: 穷举</li>
<li>三要素<ol>
<li>重叠子问题<ol>
<li>备忘录</li>
<li>dp table</li>
</ol>
</li>
<li>符合最优子结构: 要符合「最优子结构」，子问题间必须互相独立</li>
<li>能写出状态转移方程</li>
</ol>
</li>
<li>例子<ol>
<li>斐波那契数列</li>
<li>凑零钱</li>
</ol>
</li>
<li>注意:<ol>
<li>递归算法的时间复杂度怎么计算?<ol>
<li>子问题个数 * 解决一个子问题需要的时间</li>
</ol>
</li>
<li>最优子结构的问题<ol>
<li>划分为动态规划问题一定会符合最优子结构,这是写出状态转移方程的必要条件.</li>
</ol>
</li>
<li>dp数组的遍历方向<ol>
<li>dp数组的遍历方向主要是看下一次计算结果依赖于前面的计算结果还是依赖于后面的计算结果.在遍历到i时,必须保证当时的max(i,j,k)其中i,j,k必须有值.方向怎么对怎么来</li>
</ol>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>凑零钱问题</title>
    <url>/2020/04/22/Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%87%91%E9%9B%B6%E9%92%B1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<a id="more"></a>

<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param Integer[] $coins</span><br><span class="line">     * @param Integer $amount</span><br><span class="line">     * @return Integer</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    function coinChange($coins, $amount) &#123;</span><br><span class="line">        $dpArray &#x3D; array_fill(0, $amount+1, $amount+1);</span><br><span class="line">        $dpArray[0] &#x3D; 0;</span><br><span class="line">        for ($i &#x3D; 0; $i &lt; ($amount+1); $i++) &#123;</span><br><span class="line">            foreach ($coins as $coin) &#123;</span><br><span class="line">                if (($i - $coin) &lt; 0) &#123;</span><br><span class="line">                    echo &quot;i &#x3D; &#123;$i&#125; -- coin &#x3D; &#123;$coin&#125;, &#123;$i&#125; &lt; &#123;$coin&#125;, continue\n&quot;;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                echo &quot;dp[&#123;$i&#125;] &#x3D; min(&#123;$dpArray[$i]&#125; , 1+&#123;$dpArray[$i-$coin]&#125;)\n&quot;;</span><br><span class="line">                $dpArray[$i] &#x3D; min($dpArray[$i], 1+$dpArray[$i-$coin]);</span><br><span class="line">            &#125;</span><br><span class="line">            echo &quot;\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return ($dpArray[$amount] &#x3D;&#x3D; $amount+1) ? -1 : $dpArray[$amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$solution &#x3D; new Solution();</span><br><span class="line">echo $solution-&gt;coinChange([1,2,5], 11);</span><br></pre></td></tr></table></figure>

<h5 id="运算过程"><a href="#运算过程" class="headerlink" title="运算过程"></a>运算过程</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i &#x3D; 0 -- coin &#x3D; 1, 0 &lt; 1, continue</span><br><span class="line">i &#x3D; 0 -- coin &#x3D; 2, 0 &lt; 2, continue</span><br><span class="line">i &#x3D; 0 -- coin &#x3D; 5, 0 &lt; 5, continue</span><br><span class="line"></span><br><span class="line">dp[1] &#x3D; min(12 , 1+0)</span><br><span class="line">i &#x3D; 1 -- coin &#x3D; 2, 1 &lt; 2, continue</span><br><span class="line">i &#x3D; 1 -- coin &#x3D; 5, 1 &lt; 5, continue</span><br><span class="line"></span><br><span class="line">dp[2] &#x3D; min(12 , 1+1)</span><br><span class="line">dp[2] &#x3D; min(2 , 1+0)</span><br><span class="line">i &#x3D; 2 -- coin &#x3D; 5, 2 &lt; 5, continue</span><br><span class="line"></span><br><span class="line">dp[3] &#x3D; min(12 , 1+1)</span><br><span class="line">dp[3] &#x3D; min(2 , 1+1)</span><br><span class="line">i &#x3D; 3 -- coin &#x3D; 5, 3 &lt; 5, continue</span><br><span class="line"></span><br><span class="line">dp[4] &#x3D; min(12 , 1+2)</span><br><span class="line">dp[4] &#x3D; min(3 , 1+1)</span><br><span class="line">i &#x3D; 4 -- coin &#x3D; 5, 4 &lt; 5, continue</span><br><span class="line"></span><br><span class="line">dp[5] &#x3D; min(12 , 1+2)</span><br><span class="line">dp[5] &#x3D; min(3 , 1+2)</span><br><span class="line">dp[5] &#x3D; min(3 , 1+0)</span><br><span class="line"></span><br><span class="line">dp[6] &#x3D; min(12 , 1+1)</span><br><span class="line">dp[6] &#x3D; min(2 , 1+2)</span><br><span class="line">dp[6] &#x3D; min(2 , 1+1)</span><br><span class="line"></span><br><span class="line">dp[7] &#x3D; min(12 , 1+2)</span><br><span class="line">dp[7] &#x3D; min(3 , 1+1)</span><br><span class="line">dp[7] &#x3D; min(2 , 1+1)</span><br><span class="line"></span><br><span class="line">dp[8] &#x3D; min(12 , 1+2)</span><br><span class="line">dp[8] &#x3D; min(3 , 1+2)</span><br><span class="line">dp[8] &#x3D; min(3 , 1+2)</span><br><span class="line"></span><br><span class="line">dp[9] &#x3D; min(12 , 1+3)</span><br><span class="line">dp[9] &#x3D; min(4 , 1+2)</span><br><span class="line">dp[9] &#x3D; min(3 , 1+2)</span><br><span class="line"></span><br><span class="line">dp[10] &#x3D; min(12 , 1+3)</span><br><span class="line">dp[10] &#x3D; min(4 , 1+3)</span><br><span class="line">dp[10] &#x3D; min(4 , 1+1)</span><br><span class="line"></span><br><span class="line">dp[11] &#x3D; min(12 , 1+2)</span><br><span class="line">dp[11] &#x3D; min(3 , 1+3)</span><br><span class="line">dp[11] &#x3D; min(3 , 1+2)</span><br><span class="line"></span><br><span class="line">3</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>从 PHP 7.2.x 移植到 PHP 7.3.x的变更</title>
    <url>/2019/09/18/PHP/PHP%E7%89%88%E6%9C%AC%E5%8F%98%E6%9B%B4%E8%AE%B0%E5%BD%95/%E4%BB%8E-PHP-7-2-x-%E7%A7%BB%E6%A4%8D%E5%88%B0-PHP-7-3-x%E7%9A%84%E5%8F%98%E6%9B%B4/</url>
    <content><![CDATA[<blockquote>
<p>参考文章</p>
<ol>
<li><a href="https://www.php.net/manual/zh/migration73.php" target="_blank" rel="noopener">从 PHP 7.2.x 移植到 PHP 7.3.x</a></li>
</ol>
</blockquote>
<a id="more"></a>

<h3 id="New-Features"><a href="#New-Features" class="headerlink" title="New Features"></a>New Features</h3><h5 id="PHP-Core"><a href="#PHP-Core" class="headerlink" title="PHP Core"></a>PHP Core</h5><h3 id="新函数"><a href="#新函数" class="headerlink" title="新函数"></a>新函数</h3><ul>
<li><a href="https://www.php.net/manual/zh/function.array-key-first.php" target="_blank" rel="noopener">array_key_first ( array $array ) : mixed</a> Get the first key of the given array <strong>without affecting the internal array pointer</strong>.</li>
<li><a href="https://www.php.net/manual/zh/function.array-key-last.php" target="_blank" rel="noopener">array_key_last ( array $array ) : mixed</a> Get the last key of the given array <strong>without affecting the internal array pointer</strong>.</li>
</ul>
<h3 id="废弃的功能"><a href="#废弃的功能" class="headerlink" title="废弃的功能"></a>废弃的功能</h3><h5 id="大小写不敏感的常量"><a href="#大小写不敏感的常量" class="headerlink" title="大小写不敏感的常量"></a>大小写不敏感的常量</h5><p>大小写不敏感的常量声明现已被废弃。将 TRUE 作为第三个参数传递给 define() 将会导致一个废弃警告。大小写不敏感的使用（在读取时使用一个与声明时不同的大小写方式）也已被废弃。</p>
<h5 id="在字符串中搜索非字符串内容"><a href="#在字符串中搜索非字符串内容" class="headerlink" title="在字符串中搜索非字符串内容"></a>在字符串中搜索非字符串内容</h5><p>废弃：将一个非字符串内容传递给字符串搜索函数。 在将来所有待搜索的内容都将被视为字符串，而不是 ASCII 编码值。如果需要依赖这个特性，你应该 要么显示地进行类型转换（转为字符串），或者显示地调用 chr()。 以下是受到影响的方法：</p>
<ul>
<li>strpos()</li>
<li>strrpos()</li>
<li>stripos()</li>
<li>strripos()</li>
<li>strstr()</li>
<li>strchr()</li>
<li>strrchr()</li>
<li>stristr()</li>
</ul>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>从PHP 7.0.x 移植到 PHP 7.1.x的变更</title>
    <url>/2019/09/17/PHP/PHP%E7%89%88%E6%9C%AC%E5%8F%98%E6%9B%B4%E8%AE%B0%E5%BD%95/%E4%BB%8EPHP%207.0.x%20%E7%A7%BB%E6%A4%8D%E5%88%B0%20PHP%207.1.x%E7%9A%84%E5%8F%98%E6%9B%B4/</url>
    <content><![CDATA[<blockquote>
<p>参考文档</p>
<ol>
<li><a href="https://www.php.net/manual/zh/migration71.php" target="_blank" rel="noopener">从PHP 7.0.x 移植到 PHP 7.1.x</a></li>
</ol>
</blockquote>
<a id="more"></a>

<h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><h5 id="可为空（Nullable）类型"><a href="#可为空（Nullable）类型" class="headerlink" title="可为空（Nullable）类型"></a>可为空（Nullable）类型</h5><p>参数以及返回值的类型现在可以通过在类型前加上一个问号使之允许为空。 当启用这个特性时，传入的参数或者函数返回的结果<strong>要么是给定的类型，要么是 null</strong> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">function testReturn(): ?string&#123;</span><br><span class="line">    return &#39;elePHPant&#39;;</span><br><span class="line">&#125;</span><br><span class="line">var_dump(testReturn());</span><br><span class="line"></span><br><span class="line">function testReturn(): ?string&#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">var_dump(testReturn());</span><br><span class="line"></span><br><span class="line">function test(?string $name)&#123;</span><br><span class="line">    var_dump($name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(&#39;elePHPant&#39;);</span><br><span class="line">test(null);</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line">以上例程会输出：</span><br><span class="line">string(10) &quot;elePHPant&quot;</span><br><span class="line">NULL</span><br><span class="line">string(10) &quot;elePHPant&quot;</span><br><span class="line">NULL</span><br><span class="line">Uncaught Error: Too few arguments to function test(), 0 passed in...</span><br></pre></td></tr></table></figure>

<h5 id="强推Symmetric-array-destructuring"><a href="#强推Symmetric-array-destructuring" class="headerlink" title="强推Symmetric array destructuring"></a>强推Symmetric array destructuring</h5><p>短数组语法（[]）现在作为list()语法的一个备选项，可以用于将数组的值赋给一些变量（包括在foreach中）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$data &#x3D; [</span><br><span class="line">    [1, &#39;Tom&#39;],</span><br><span class="line">    [2, &#39;Fred&#39;],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; list() style</span><br><span class="line">list($id1, $name1) &#x3D; $data[0];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [] style</span><br><span class="line">[$id1, $name1] &#x3D; $data[0];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; list() style</span><br><span class="line">foreach ($data as list($id, $name)) &#123;</span><br><span class="line">    &#x2F;&#x2F; logic here with $id and $name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [] style</span><br><span class="line">foreach ($data as [$id, $name]) &#123;</span><br><span class="line">    &#x2F;&#x2F; logic here with $id and $name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="多异常捕获处理"><a href="#多异常捕获处理" class="headerlink" title="多异常捕获处理"></a>多异常捕获处理</h5><p>一个catch语句块现在可以通过管道字符(|)来实现多个异常的捕获。 这对于需要同时处理来自不同类的不同异常时很有用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">try &#123;</span><br><span class="line">    &#x2F;&#x2F; some code</span><br><span class="line">&#125; catch (FirstException | SecondException $e) &#123;</span><br><span class="line">    &#x2F;&#x2F; handle first and second exceptions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="list现在支持键名"><a href="#list现在支持键名" class="headerlink" title="list现在支持键名"></a>list现在支持键名</h5><p>现在list()和它的新的[]语法支持在它内部去指定键名。这意味着它可以将任意类型的数组 都赋值给一些变量（与短数组语法类似）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$data &#x3D; [</span><br><span class="line">    [&quot;id&quot; &#x3D;&gt; 1, &quot;name&quot; &#x3D;&gt; &#39;Tom&#39;],</span><br><span class="line">    [&quot;id&quot; &#x3D;&gt; 2, &quot;name&quot; &#x3D;&gt; &#39;Fred&#39;],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; list() style</span><br><span class="line">list(&quot;id&quot; &#x3D;&gt; $id1, &quot;name&quot; &#x3D;&gt; $name1) &#x3D; $data[0];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [] style</span><br><span class="line">[&quot;id&quot; &#x3D;&gt; $id1, &quot;name&quot; &#x3D;&gt; $name1] &#x3D; $data[0];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; list() style</span><br><span class="line">foreach ($data as list(&quot;id&quot; &#x3D;&gt; $id, &quot;name&quot; &#x3D;&gt; $name)) &#123;</span><br><span class="line">    &#x2F;&#x2F; logic here with $id and $name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [] style</span><br><span class="line">foreach ($data as [&quot;id&quot; &#x3D;&gt; $id, &quot;name&quot; &#x3D;&gt; $name]) &#123;</span><br><span class="line">    &#x2F;&#x2F; logic here with $id and $name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="支持为负的字符串偏移量"><a href="#支持为负的字符串偏移量" class="headerlink" title="支持为负的字符串偏移量"></a>支持为负的字符串偏移量</h5><p>现在所有支持偏移量的字符串操作函数 都支持接受负数作为偏移量，包括通过[]或{}操作字符串下标。在这种情况下，一个负数的偏移量会被理解为一个从字符串结尾开始的偏移量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">var_dump(&quot;abcdef&quot;[-2]);</span><br><span class="line">var_dump(strpos(&quot;aabbcc&quot;, &quot;b&quot;, -3));</span><br><span class="line">以上例程会输出：</span><br><span class="line"></span><br><span class="line">string (1) &quot;e&quot;</span><br><span class="line">int(3)</span><br><span class="line">Negative string and array offsets are now also supported in the simple variable parsing syntax inside of strings.</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">$string &#x3D; &#39;bar&#39;;</span><br><span class="line">echo &quot;The last character of &#39;$string&#39; is &#39;$string[-1]&#39;.\n&quot;;</span><br><span class="line">?&gt;</span><br><span class="line">以上例程会输出：</span><br><span class="line"></span><br><span class="line">The last character of &#39;bar&#39; is &#39;r&#39;.</span><br></pre></td></tr></table></figure>

<h3 id="新增的函数"><a href="#新增的函数" class="headerlink" title="新增的函数"></a>新增的函数</h3><ul>
<li><a href="https://www.php.net/manual/zh/function.is-iterable.php" target="_blank" rel="noopener">is_iterable ( mixed $var ) : bool</a></li>
</ul>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>从PHP 7.1.x 移植到 PHP 7.2.x的变更</title>
    <url>/2019/09/18/PHP/PHP%E7%89%88%E6%9C%AC%E5%8F%98%E6%9B%B4%E8%AE%B0%E5%BD%95/%E4%BB%8EPHP-7-1-x-%E7%A7%BB%E6%A4%8D%E5%88%B0-PHP-7-2-x%E7%9A%84%E5%8F%98%E6%9B%B4/</url>
    <content><![CDATA[<blockquote>
<p>参考文章</p>
<ol>
<li><a href="https://www.php.net/manual/zh/migration72.php" target="_blank" rel="noopener">从PHP 7.1.x 移植到 PHP 7.2.x</a></li>
</ol>
</blockquote>
<a id="more"></a>

<h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><h5 id="新的对象类型object"><a href="#新的对象类型object" class="headerlink" title="新的对象类型object"></a>新的对象类型object</h5><p>引进了可用于逆变（contravariant）参数输入和协变（covariant）返回任何对象类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function test(object $obj) : object&#123;</span><br><span class="line">    return new SplQueue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(new StdClass());</span><br></pre></td></tr></table></figure>

<h5 id="通过名称加载扩展"><a href="#通过名称加载扩展" class="headerlink" title="通过名称加载扩展"></a>通过名称加载扩展</h5><p>扩展文件不再需要通过文件加载 (Unix下以.so为文件扩展名，在Windows下以 .dll 为文件扩展名) 进行指定。可以在php.ini配置文件进行启用, 也可以使用 dl() 函数进行启用。</p>
<h5 id="允许重写抽象方法-Abstract-method"><a href="#允许重写抽象方法-Abstract-method" class="headerlink" title="允许重写抽象方法(Abstract method)"></a>允许重写抽象方法(Abstract method)</h5><p>当一个抽象类继承于另外一个抽象类的时候，继承后的抽象类可以重写被继承的抽象类的抽象方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">abstract class A&#123;</span><br><span class="line">    abstract function test(string $s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class B extends A&#123;</span><br><span class="line">    &#x2F;&#x2F; overridden - still maintaining contravariance for parameters and covariance for return</span><br><span class="line">    abstract function test($s) : int;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="废弃的功能"><a href="#废弃的功能" class="headerlink" title="废弃的功能"></a>废弃的功能</h3><h5 id="autoload-方法"><a href="#autoload-方法" class="headerlink" title="__autoload() 方法"></a>__autoload() 方法</h5><p>__autoload() 方法已被废弃， 因为和 spl_autoload_register() 相比功能较差 (因为无法链式处理多个 autoloader)， 而且也无法在两种 autoloading 样式中配合使用。</p>
<h5 id="each-函数"><a href="#each-函数" class="headerlink" title="each() 函数"></a>each() 函数</h5><p>使用此函数遍历时，比普通的 foreach 更慢， 并且给新语法的变化带来实现问题。因此它被废弃了。</p>
<h5 id="assert-一个字符串参数"><a href="#assert-一个字符串参数" class="headerlink" title="assert() 一个字符串参数"></a>assert() 一个字符串参数</h5><p>assert() 字符串参数将要求它能被 eval() 执行。 考虑到可能被执行远程代码，废弃了字符串的 assert()，最好提供 bool 的表达式。</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>PSR-1 基础编码规范</title>
    <url>/2019/11/18/PHP/PSR%20%E8%A7%84%E8%8C%83/PSR-1-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<blockquote>
<p>搬自<a href="https://learnku.com/docs/psr" target="_blank" rel="noopener">PHP PSR 标准规范</a></p>
</blockquote>
<a id="more"></a>
<h4 id="基本代码规范"><a href="#基本代码规范" class="headerlink" title="基本代码规范"></a>基本代码规范</h4><p>本篇规范制定了代码基本元素的相关标准，以确保共享的 PHP 代码间具有较高程度的技术互通性。</p>
<h4 id="关于「能愿动词」的使用"><a href="#关于「能愿动词」的使用" class="headerlink" title="关于「能愿动词」的使用"></a>关于「能愿动词」的使用</h4><p>为了避免歧义，文档大量使用了「能愿动词」，对应的解释如下：</p>
<ul>
<li><code>必须 (MUST)：绝对</code>，严格遵循，请照做，无条件遵守；</li>
<li><code>一定不可 (MUST NOT)</code>：禁令，严令禁止；</li>
<li><code>应该 (SHOULD)</code>：强烈建议这样做，但是不强求；</li>
<li><code>不该 (SHOULDNOT)</code>：强烈不建议这样做，但是不强求；</li>
<li><code>可以 (MAY)</code> 和 <code>可选 (OPTIONAL)</code>：选择性高一点，在这个文档内，此词语使用较少；</li>
</ul>
<h5 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h5><ul>
<li><p>PHP 代码文件 <strong>必须</strong> 以 <code>&lt;?php</code> 或 <code>&lt;?=</code> 标签开始；</p>
</li>
<li><p>PHP 代码文件 <strong>必须</strong> 以 不带 <code>BOM 的 UTF-8</code> 编码；</p>
</li>
<li><p>PHP 代码中 <strong>应该</strong> 只定义类、函数、常量等声明，或其他会产生 副作用 的操作（如：生成文件输出以及修改 .ini 配置文件等），二者只能选其一；</p>
</li>
<li><p>命名空间以及类 <strong>必须</strong> 符合 PSR 的自动加载规范：PSR-4 中的一个；</p>
</li>
<li><p>类的命名 <strong>必须</strong> 遵循 <code>StudlyCaps</code> 大写开头的驼峰命名规范；</p>
</li>
<li><p>类中的常量所有字母都 <strong>必须</strong> 大写，单词间用下划线分隔；</p>
</li>
<li><p>方法名称 <strong>必须</strong> 符合 <code>camelCase</code> 式的小写开头驼峰命名规范。</p>
</li>
</ul>
<h5 id="2-文件"><a href="#2-文件" class="headerlink" title="2. 文件"></a>2. 文件</h5><h6 id="2-1-PHP-标签"><a href="#2-1-PHP-标签" class="headerlink" title="2.1. PHP 标签"></a>2.1. PHP 标签</h6><p>PHP 代码 必须 使用 <?php ?> 长标签 或 <?= ?> 短输出标签；<br>一定不可 使用其它自定义标签。</p>
<h6 id="2-2-字符编码"><a href="#2-2-字符编码" class="headerlink" title="2.2. 字符编码"></a>2.2. 字符编码</h6><p>PHP 代码 必须 且只可使用 不带BOM的UTF-8 编码。</p>
<h6 id="2-3-副作用"><a href="#2-3-副作用" class="headerlink" title="2.3. 副作用"></a>2.3. 副作用</h6><p>一份 PHP 文件中 应该 要不就只定义新的声明，如类、函数或常量等不产生 副作用 的操作，要不就只书写会产生 副作用 的逻辑操作，但 不该 同时具有两者。</p>
<p>「副作用」(side effects) 一词的意思是，仅仅通过包含文件，不直接声明类、函数和常量等，而执行的逻辑操作。</p>
<p>「副作用」包含却不仅限于：</p>
<ul>
<li>生成输出</li>
<li>直接的 <code>require</code> 或 <code>include</code></li>
<li>连接外部服务</li>
<li>修改 ini 配置</li>
<li>抛出错误或异常</li>
<li>修改全局或静态变量</li>
<li>读或写文件等<br>以下是一个 <code>反例</code>，一份包含「函数声明」以及产生「副作用」的代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F; 「副作用」：修改 ini 配置</span><br><span class="line">ini_set(&#39;error_reporting&#39;, E_ALL);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 「副作用」：引入文件</span><br><span class="line">include &quot;file.php&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 「副作用」：生成输出</span><br><span class="line">echo &quot;&lt;html&gt;\n&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 声明函数</span><br><span class="line">function foo()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 函数主体部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>下面是一个<code>范例</code>，一份只包含声明不产生「副作用」的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F; 声明函数</span><br><span class="line">function foo()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 函数主体部分</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 条件声明 **不** 属于「副作用」</span><br><span class="line">if (! function_exists(&#39;bar&#39;)) &#123;</span><br><span class="line">    function bar()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 函数主体部分</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-命名空间和类"><a href="#3-命名空间和类" class="headerlink" title="3. 命名空间和类"></a>3. 命名空间和类</h5><p>命名空间以及类的命名必须遵循 PSR-4。</p>
<p>根据规范，每个类都独立为一个文件，且命名空间至少有一个层次：顶级的组织名称（vendor name）。</p>
<p>类的命名 必须 遵循 StudlyCaps 大写开头的驼峰命名规范。</p>
<p>PHP 5.3 及以后版本的代码 必须 使用正式的命名空间。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F; PHP 5.3及以后版本的写法</span><br><span class="line">namespace Vendor\Model;</span><br><span class="line"></span><br><span class="line">class Foo</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.2.x 及之前的版本 应该 使用伪命名空间的写法，约定俗成使用顶级的组织名称（vendor name）如 <code>Vendor_</code> 为类前缀。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F; 5.2.x及之前版本的写法</span><br><span class="line">class Vendor_Model_Foo</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-类的常量、属性和方法"><a href="#4-类的常量、属性和方法" class="headerlink" title="4. 类的常量、属性和方法"></a>4. 类的常量、属性和方法</h5><p>此处的「类」指代所有的类、接口以及可复用代码块（traits）。</p>
<h6 id="4-1-常量"><a href="#4-1-常量" class="headerlink" title="4.1. 常量"></a>4.1. 常量</h6><p>类的常量中所有字母都 必须 大写，词间以下划线分隔。</p>
<p>参照以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace Vendor\Model;</span><br><span class="line"></span><br><span class="line">class Foo</span><br><span class="line">&#123;</span><br><span class="line">    const VERSION &#x3D; &#39;1.0&#39;;</span><br><span class="line">    const DATE_APPROVED &#x3D; &#39;2012-06-01&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-2-属性"><a href="#4-2-属性" class="headerlink" title="4.2. 属性"></a>4.2. 属性</h6><p>类的属性命名 可以 遵循：</p>
<ul>
<li>大写开头的驼峰式 ($StudlyCaps)</li>
<li>小写开头的驼峰式 ($camelCase)</li>
<li>下划线分隔式 ($under_score)</li>
</ul>
<p>本规范不做强制要求，但无论遵循哪种命名方式，都 应该 在一定的范围内保持一致。这个范围可以是整个团队、整个包、整个类或整个方法。</p>
<h6 id="4-3-方法"><a href="#4-3-方法" class="headerlink" title="4.3. 方法"></a>4.3. 方法</h6><p>方法名称 <strong>必须</strong> 符合 <code>camelCase()</code> 式的小写开头驼峰命名规范。</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim学习</title>
    <url>/2019/09/28/linux/vim/Vim%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<blockquote>
<p>参考文章</p>
<ol>
<li><a href="https://vim.wxnacy.com/#README" target="_blank" rel="noopener">Vim练级手册</a></li>
</ol>
</blockquote>
<a id="more"></a>

<h4 id="键位操作"><a href="#键位操作" class="headerlink" title="键位操作"></a>键位操作</h4><h5 id="快速移动光标"><a href="#快速移动光标" class="headerlink" title="快速移动光标"></a>快速移动光标</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">w           &quot; 移动到下一个单词开头</span><br><span class="line">e           &quot; 移动到单词的结尾</span><br><span class="line">b           &quot; 移动到单词的开头</span><br></pre></td></tr></table></figure>

<h5 id="上下左右"><a href="#上下左右" class="headerlink" title="上下左右"></a>上下左右</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h  j  k l</span><br><span class="line">← ↓ ↑ →</span><br></pre></td></tr></table></figure>

<h5 id="行首行尾"><a href="#行首行尾" class="headerlink" title="行首行尾"></a>行首行尾</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 快速跳到行首</span><br><span class="line">$ 快速跳到行尾</span><br></pre></td></tr></table></figure>

<h6 id="页头页尾"><a href="#页头页尾" class="headerlink" title="页头页尾"></a>页头页尾</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gg 快速跳到第一行</span><br><span class="line">G 快速跳到最后一行</span><br></pre></td></tr></table></figure>

<h5 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;word   &quot; 输入 &#x2F; 会进入 command 模式，再输入先要搜索的单词并回车进行搜索</span><br><span class="line">?word   &quot; &#x2F; 是向光标以后搜索，? 是向前搜索</span><br><span class="line">n       &quot; 英文字母 n，根据 &#x2F; 或 ? 搜索的方向定位到下一个匹配目标</span><br><span class="line">N       &quot; 与 n 相反，定位匹配目标</span><br></pre></td></tr></table></figure>

<h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g   &quot; n1, n2 表示数字，替换 n1 行到 n2 行的单词</span><br><span class="line">:1,$s&#x2F;word1&#x2F;word2&#x2F;g     &quot; 全文替换，也可以写成 :%s&#x2F;word1&#x2F;word2&#x2F;g</span><br><span class="line">:1,$s&#x2F;word1&#x2F;word2&#x2F;gc    &quot; 全文替换，并出现确认提示</span><br></pre></td></tr></table></figure>

<h5 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dd          &quot; 删除当前行</span><br><span class="line">ndd         &quot; 向下删除 n 行</span><br><span class="line">d1G &#x2F; dgg   &quot; 删除第一行到当前行的数据</span><br><span class="line">dG          &quot; 删除当前行到最后一行的数据</span><br><span class="line">d$          &quot; 删除当前字符到行尾</span><br><span class="line">d0          &quot; 从行首删除到当前字符</span><br><span class="line">yy          &quot; 复制当前行</span><br><span class="line">nyy         &quot; 从当前行开始复制 n 行</span><br><span class="line">y1G &#x2F; ygg   &quot; 从第一行复制到当前行</span><br><span class="line">yG          &quot; 从当前行复制到最后一行</span><br><span class="line">y0          &quot; 从行首复制到当前字符</span><br><span class="line">y$          &quot; 从当前字符复制到行尾</span><br><span class="line">p, P        &quot; 黏贴，p 黏贴到光标下一行，P 黏贴到光标上一行</span><br></pre></td></tr></table></figure>

<h5 id="撤销重做"><a href="#撤销重做" class="headerlink" title="撤销重做"></a>撤销重做</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u        &quot; 撤销</span><br><span class="line">ctrl+r   &quot; 重做</span><br></pre></td></tr></table></figure>

<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><h5 id="insert模式"><a href="#insert模式" class="headerlink" title="insert模式"></a>insert模式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i   &quot; 在光标前进入 insert 模式</span><br><span class="line">I   &quot; 在当前行左边第一个非空字符前进入 insert 模式，类似其他编辑器的 &lt;c-a&gt; 快捷键</span><br><span class="line">a   &quot; 在光标后进入 insert 模式</span><br><span class="line">A   &quot; 在当前行右边第一个非空字符前进入 insert 模式，类似其他编辑器的 &lt;c-e&gt; 快捷键</span><br><span class="line">o   &quot; 在光标的下一行插入</span><br><span class="line">O   &quot; 在光标的上一行插入</span><br><span class="line">s   &quot; 删除当前字符，并进入 insert 模式&quot;</span><br><span class="line">S   &quot; 删除当前行，并进入插入模式</span><br><span class="line">cc  &quot; 删除当前行，并进入插入模式</span><br></pre></td></tr></table></figure>

<h4 id="vimrc配置文件"><a href="#vimrc配置文件" class="headerlink" title="vimrc配置文件"></a>vimrc配置文件</h4><p><a href="https://vim.wxnacy.com/#docs/vimrc" target="_blank" rel="noopener">参考配置</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set number &quot;显示行号</span><br><span class="line">set cursorline &quot;突出显示当前行</span><br><span class="line">set cursorcolumn &quot;突出显示当前列</span><br><span class="line">syntax on &quot;开启语法高亮</span><br><span class="line">filetype on &quot;开启文件类型检测</span><br><span class="line">filetype plugin on &quot;开启插件支持</span><br><span class="line">filetype indent on &quot;开启文件类型相应的缩进规则</span><br><span class="line">set showmode  &quot;显示当前vim模式</span><br><span class="line">set showmatch &quot;显示匹配的括号</span><br><span class="line">set hlsearch &quot;高亮搜索项</span><br><span class="line">set tabstop&#x3D;4 &quot;键入tab的步长</span><br><span class="line">set laststatus&#x3D;2   &quot; 底部显示两行状态栏&quot;</span><br></pre></td></tr></table></figure>

<h5 id="高级键位"><a href="#高级键位" class="headerlink" title="高级键位"></a>高级键位</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZZ 直接退出</span><br><span class="line">:q! 强制退出</span><br><span class="line">:w! 强制保存</span><br><span class="line">:w ! sudo tee % 在vim中强制使用sudo保存以解决权限不够的问题</span><br><span class="line">:w newfilename 另存为</span><br></pre></td></tr></table></figure>

<h4 id="多窗口操作"><a href="#多窗口操作" class="headerlink" title="多窗口操作"></a>多窗口操作</h4><h5 id="分割窗口"><a href="#分割窗口" class="headerlink" title="分割窗口"></a>分割窗口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:sp filename    &quot; 上下分割窗口</span><br><span class="line">:vsp filename   &quot; 左右分割窗口</span><br></pre></td></tr></table></figure>

<h5 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;c-w&gt;h[j[k[l]]]     &quot; 根据方向键移动光标到该方向的窗口上</span><br></pre></td></tr></table></figure>

<h5 id="调换窗口位置"><a href="#调换窗口位置" class="headerlink" title="调换窗口位置"></a>调换窗口位置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;c-w&gt;x      &quot; 对调左右或上下两个对应的窗口</span><br></pre></td></tr></table></figure>

<h5 id="退出窗口"><a href="#退出窗口" class="headerlink" title="退出窗口"></a>退出窗口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;c-w&gt;q</span><br><span class="line">一般也可以先移动光标到该窗口,然后:q</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim安装nerdtree</title>
    <url>/2019/10/10/linux/vim/Vim%E5%AE%89%E8%A3%85nerdtree/</url>
    <content><![CDATA[<blockquote>
<p>参考文章</p>
<ol>
<li><a href="https://juejin.im/post/5c1fa6e4f265da6167205011" target="_blank" rel="noopener">掘金-nerdtree安装</a></li>
<li><a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="noopener">vim-github</a></li>
</ol>
</blockquote>
<a id="more"></a>

<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 把项目download下来</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;scrooloose&#x2F;nerdtree.git ~&#x2F;.vim&#x2F;bundle&#x2F;nerdtree</span><br><span class="line"></span><br><span class="line">2. 在.vim下创建plugin和doc目录</span><br><span class="line">$ mkdir -p ~&#x2F;.vim&#x2F;&#123;plugin,doc&#125;</span><br><span class="line"> </span><br><span class="line">3. 复制nerdtree的文件</span><br><span class="line">$ cd nerdtree</span><br><span class="line">$ cp plugin&#x2F;NERD_tree.vim ~&#x2F;.vim&#x2F;plugin&#x2F;</span><br><span class="line">$ cp doc&#x2F;NERD_tree.txt ~&#x2F;.vim&#x2F;doc&#x2F;</span><br></pre></td></tr></table></figure>
<p>安装好之后.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim test.log</span><br><span class="line">$ 在vim中输入:NERDTree</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Wuyiwai/Source/master/20191010101058.png" alt="vim nerdtree"></p>
<h5 id="设置快捷键"><a href="#设置快捷键" class="headerlink" title="设置快捷键"></a>设置快捷键</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 修改vim配置</span><br><span class="line">$ vim ~&#x2F;.vimrc</span><br><span class="line"></span><br><span class="line">2. 添加下列配置</span><br><span class="line">map &lt;F10&gt; :NERDTreeMirror&lt;CR&gt;</span><br><span class="line">map &lt;F10&gt; :NERDTreeToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure>

<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ol>
<li>cp之后如果遇到报错.把<del>/.vim/bundle/nerdtree目录下所有文件cp到</del>/.vim下即可,合并cp而不是替换cp</li>
</ol>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>从PHP 5.6.x 移植到 PHP 7.0.x的变更</title>
    <url>/2019/09/17/PHP/PHP%E7%89%88%E6%9C%AC%E5%8F%98%E6%9B%B4%E8%AE%B0%E5%BD%95/%E4%BB%8EPHP%205.6.x%20%E7%A7%BB%E6%A4%8D%E5%88%B0%20PHP%207.0.x%E7%9A%84%E5%8F%98%E6%9B%B4/</url>
    <content><![CDATA[<blockquote>
<p>参考文章</p>
<ol>
<li><a href="https://www.php.net/manual/zh/migration70.php" target="_blank" rel="noopener">PHP5.6到PHP7.0的变更</a></li>
</ol>
</blockquote>
<a id="more"></a>

<h3 id="不向后兼容的变更"><a href="#不向后兼容的变更" class="headerlink" title="不向后兼容的变更"></a>不向后兼容的变更</h3><h4 id="错误和异常处理相关的变更"><a href="#错误和异常处理相关的变更" class="headerlink" title="错误和异常处理相关的变更"></a>错误和异常处理相关的变更</h4><p>在PHP 7 中，很多致命错误以及可恢复的致命错误，都被转换为异常来处理了。 这些异常继承自 <strong>Error</strong> 类，此类实现了 <strong>Throwable</strong> 接口 （所有异常都实现了这个基础接口）。</p>
<p>这也意味着，当发生错误的时候，以前代码中的一些错误处理的代码将无法被触发。 因为在 PHP 7 版本中，已经使用抛出异常的错误处理机制了。 （如果代码中没有捕获 Error 异常，那么会引发致命错误）。</p>
<p>PHP 7 中的错误处理的更完整的描述，请参见 <a href="https://www.php.net/manual/zh/language.errors.php7.php" target="_blank" rel="noopener">PHP 7 错误处理</a>。 本迁移指导主要是列出对兼容性有影响的变更。</p>
<h5 id="set-exception-handler-不再保证收到的一定是-Exception-对象"><a href="#set-exception-handler-不再保证收到的一定是-Exception-对象" class="headerlink" title="set_exception_handler() 不再保证收到的一定是 Exception 对象"></a>set_exception_handler() 不再保证收到的一定是 Exception 对象</h5><p>抛出 Error 对象时，如果 set_exception_handler() 里的异常处理代码声明了类型 Exception ，将会导致 fatal error。</p>
<p>想要异常处理器同时支持 PHP5 和 PHP7，应该删掉异常处理器里的类型声明。如果代码仅仅是升级到 PHP7，则可以把类型 Exception 替换成 Throwable。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F; PHP 5 时代的代码将会出现问题</span><br><span class="line">function handler(Exception $e) &#123; ... &#125;</span><br><span class="line">set_exception_handler(&#39;handler&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 兼容 PHP 5 和 7</span><br><span class="line">function handler($e) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 仅支持 PHP 7</span><br><span class="line">function handler(Throwable $e) &#123; ... &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="间接使用变量、属性和方法的变化"><a href="#间接使用变量、属性和方法的变化" class="headerlink" title="间接使用变量、属性和方法的变化"></a>间接使用变量、属性和方法的变化</h5><table>
<thead>
<tr>
<th>表达式</th>
<th>PHP 5 的解析方式</th>
<th>PHP 7 的解析方式</th>
</tr>
</thead>
<tbody><tr>
<td>$$foo[‘bar’][‘baz’]</td>
<td>${$foo[‘bar’][‘baz’]}</td>
<td>($$foo)[‘bar’][‘baz’]</td>
</tr>
<tr>
<td>$foo-&gt;$bar[‘baz’]</td>
<td>$foo-&gt;{$bar[‘baz’]}</td>
<td>($foo-&gt;$bar)[‘baz’]</td>
</tr>
<tr>
<td>$foo-&gt;$bar[‘baz’] ()</td>
<td>$foo-&gt;{$bar[‘baz’]}()</td>
<td>($foo-&gt;$bar)[‘baz’] ()</td>
</tr>
<tr>
<td>Foo::$bar[‘baz’] ()</td>
<td>Foo::{$bar[‘baz’]}()</td>
<td>(Foo::$bar)[‘baz’] ()</td>
</tr>
</tbody></table>
<h5 id="list-不再以反向的顺序来进行赋值"><a href="#list-不再以反向的顺序来进行赋值" class="headerlink" title="list() 不再以反向的顺序来进行赋值"></a>list() 不再以反向的顺序来进行赋值</h5><p>list() 现在会按照变量定义的顺序来给他们进行赋值，而非反过来的顺序。 通常来说，这只会影响list() 与数组的[]操作符一起使用的案例，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">list($a[], $a[], $a[]) &#x3D; [1, 2, 3];</span><br><span class="line">var_dump($a);</span><br><span class="line">?&gt;</span><br><span class="line">Output of the above example in PHP 5:[3,2,1]</span><br><span class="line"></span><br><span class="line">Output of the above example in PHP 7:[1,2,3]</span><br></pre></td></tr></table></figure>

<h4 id="foreach的变化"><a href="#foreach的变化" class="headerlink" title="foreach的变化"></a>foreach的变化</h4><h5 id="foreach不再改变内部数组指针"><a href="#foreach不再改变内部数组指针" class="headerlink" title="foreach不再改变内部数组指针"></a>foreach不再改变内部数组指针</h5><p>在PHP7之前，当数组通过 foreach 迭代时，数组指针会移动。现在开始，不再如此，见下面代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$array &#x3D; [0, 1, 2];</span><br><span class="line">foreach ($array as &amp;$val) &#123;</span><br><span class="line">    var_dump(current($array));</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line">Output of the above example in PHP 5:</span><br><span class="line">int(1)</span><br><span class="line">int(2)</span><br><span class="line">bool(false) &#x2F;&#x2F;这个例子存疑，需要验证</span><br><span class="line"></span><br><span class="line">Output of the above example in PHP 7:</span><br><span class="line">int(0)</span><br><span class="line">int(0)</span><br><span class="line">int(0)</span><br></pre></td></tr></table></figure>

<h5 id="foreach-通过值遍历时，操作的值为数组的副本。"><a href="#foreach-通过值遍历时，操作的值为数组的副本。" class="headerlink" title="foreach 通过值遍历时，操作的值为数组的副本。"></a>foreach 通过值遍历时，操作的值为数组的副本。</h5><p>当默认使用通过值遍历数组时，foreach 实际操作的是数组的迭代副本，而非数组本身。这就意味着，foreach 中的操作不会修改原数组的值。</p>
<p>这其实也意味着有一定的内存成本。yield使用时可以减轻这种迭代成本。</p>
<h5 id="十六进制字符串不再被认为是数字"><a href="#十六进制字符串不再被认为是数字" class="headerlink" title="十六进制字符串不再被认为是数字"></a>十六进制字符串不再被认为是数字</h5><p>含十六进制字符串不再被认为是数字。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">var_dump(&quot;0x123&quot; &#x3D;&#x3D; &quot;291&quot;);</span><br><span class="line">var_dump(is_numeric(&quot;0x123&quot;));</span><br><span class="line">var_dump(&quot;0xe&quot; + &quot;0x1&quot;);</span><br><span class="line">var_dump(substr(&quot;foo&quot;, &quot;0x1&quot;));</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">Output of the above example in PHP 5:</span><br><span class="line">bool(true)</span><br><span class="line">bool(true)</span><br><span class="line">int(15)</span><br><span class="line">string(2) &quot;oo&quot;</span><br><span class="line"></span><br><span class="line">Output of the above example in PHP 7:</span><br><span class="line">bool(false)</span><br><span class="line">bool(false)</span><br><span class="line">int(0)</span><br><span class="line"></span><br><span class="line">Notice: A non well formed numeric value encountered in &#x2F;tmp&#x2F;test.php on line 5</span><br><span class="line">string(3) &quot;foo&quot;</span><br></pre></td></tr></table></figure>
<p>filter_var() 函数可以用于检查一个 string 是否含有十六进制数字,并将其转换为integer:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$str &#x3D; &quot;0xffff&quot;;</span><br><span class="line">$int &#x3D; filter_var($str, FILTER_VALIDATE_INT, FILTER_FLAG_ALLOW_HEX);</span><br><span class="line">if (false &#x3D;&#x3D;&#x3D; $int) &#123;</span><br><span class="line">    throw new Exception(&quot;Invalid integer!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">var_dump($int); &#x2F;&#x2F; int(65535)</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="所有-ext-mysql-函数已被删掉"><a href="#所有-ext-mysql-函数已被删掉" class="headerlink" title="所有 ext/mysql 函数已被删掉"></a>所有 ext/mysql 函数已被删掉</h5><p>如何选择不同的 MySQL API，详情请见 选择 <a href="https://www.php.net/manual/zh/mysqlinfo.api.choosing.php" target="_blank" rel="noopener">MySQL API</a>。</p>
<h5 id="yield-变更为右联接运算符，可以通过括号来消除歧义"><a href="#yield-变更为右联接运算符，可以通过括号来消除歧义" class="headerlink" title="yield 变更为右联接运算符，可以通过括号来消除歧义"></a>yield 变更为右联接运算符，可以通过括号来消除歧义</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo yield -1;</span><br><span class="line">&#x2F;&#x2F; 在之前版本中会被解释为：</span><br><span class="line">echo (yield) - 1;</span><br><span class="line">&#x2F;&#x2F; 现在，它将被解释为：</span><br><span class="line">echo yield (-1);</span><br><span class="line"></span><br><span class="line">yield $foo or die;</span><br><span class="line">&#x2F;&#x2F; 在之前版本中会被解释为：</span><br><span class="line">yield ($foo or die);</span><br><span class="line">&#x2F;&#x2F; 现在，它将被解释为：</span><br><span class="line">(yield $foo) or die;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="INI-文件中-注释格式被移除"><a href="#INI-文件中-注释格式被移除" class="headerlink" title="INI 文件中 # 注释格式被移除"></a>INI 文件中 # 注释格式被移除</h5><p>在 INI 文件中，不再支持以 # 开始的注释行， 请使用 ;（分号）来表示注释。 此变更适用于 php.ini 以及用 parse_ini_file() 和 parse_ini_string() 函数来处理的文件。</p>
<h5 id="在数值溢出的时候，内部函数将会失败"><a href="#在数值溢出的时候，内部函数将会失败" class="headerlink" title="在数值溢出的时候，内部函数将会失败"></a>在数值溢出的时候，内部函数将会失败</h5><p>将浮点数转换为整数的时候，如果浮点数值太大，导致无法以整数表达的情况下， 在之前的版本中，内部函数会直接将整数截断，并不会引发错误。 在 PHP 7.0 中，如果发生这种情况，会引发 E_WARNING 错误，并且返回 NULL。</p>
<h5 id="相等的元素在排序时的顺序问题"><a href="#相等的元素在排序时的顺序问题" class="headerlink" title="相等的元素在排序时的顺序问题"></a>相等的元素在排序时的顺序问题</h5><p>由于内部排序算法进行了提升， 可能会导致对比时被视为相等的多个元素之间的顺序不稳定。</p>
<p>在对比时被视为相等的多个元素之间的排序顺序是不可信赖的，即使是相等的两个元素， 他们的位置也可能被排序算法所改变。</p>
<h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><h5 id="标量类型声明"><a href="#标量类型声明" class="headerlink" title="标量类型声明"></a>标量类型声明</h5><p>标量类型声明 有两种模式: 强制 (默认) 和 严格模式。 现在可以使用下列类型参数（无论用强制模式还是严格模式）： 字符串(string), 整数 (int), 浮点数 (float), 以及布尔值 (bool)。它们扩充了PHP5中引入的其他类型：类名，接口，数组和 回调类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F; Coercive mode</span><br><span class="line">function sumOfInts(int ...$ints)</span><br><span class="line">&#123;</span><br><span class="line">    return array_sum($ints);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(sumOfInts(2, &#39;3&#39;, 4.1));</span><br><span class="line">以上例程会输出：</span><br><span class="line"></span><br><span class="line">int(9)</span><br></pre></td></tr></table></figure>

<p>要使用严格模式，一个 declare 声明指令必须放在文件的顶部。这意味着严格声明标量是基于文件可配的。 这个指令不仅影响参数的类型声明，也影响到函数的返回值声明（参见 返回值类型声明, 内置的PHP函数以及扩展中加载的PHP函数）</p>
<h5 id="返回值类型声明"><a href="#返回值类型声明" class="headerlink" title="返回值类型声明"></a>返回值类型声明</h5><p>PHP 7 增加了对<strong>返回类型声明</strong>的支持。类似于<strong>参数类型声明</strong>，返回类型声明<strong>指明了函数返回值的类型</strong>。可用的类型与参数声明中可用的类型相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">function arraysSum(array ...$arrays): array</span><br><span class="line">&#123;</span><br><span class="line">    return array_map(function(array $array): int &#123;</span><br><span class="line">        return array_sum($array);</span><br><span class="line">    &#125;, $arrays);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print_r(arraysSum([1,2,3], [4,5,6], [7,8,9]));</span><br><span class="line">以上例程会输出：</span><br><span class="line"></span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [0] &#x3D;&gt; 6</span><br><span class="line">    [1] &#x3D;&gt; 15</span><br><span class="line">    [2] &#x3D;&gt; 24</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="null合并运算符"><a href="#null合并运算符" class="headerlink" title="null合并运算符"></a>null合并运算符</h5><p>如果变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F; Fetches the value of $_GET[&#39;user&#39;] and returns &#39;nobody&#39;</span><br><span class="line">&#x2F;&#x2F; if it does not exist.</span><br><span class="line">$username &#x3D; $_GET[&#39;user&#39;] ?? &#39;nobody&#39;;</span><br><span class="line">&#x2F;&#x2F; This is equivalent to:</span><br><span class="line">$username &#x3D; isset($_GET[&#39;user&#39;]) ? $_GET[&#39;user&#39;] : &#39;nobody&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Coalesces can be chained: this will return the first</span><br><span class="line">&#x2F;&#x2F; defined value out of $_GET[&#39;user&#39;], $_POST[&#39;user&#39;], and</span><br><span class="line">&#x2F;&#x2F; &#39;nobody&#39;.</span><br><span class="line">$username &#x3D; $_GET[&#39;user&#39;] ?? $_POST[&#39;user&#39;] ?? &#39;nobody&#39;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="太空船操作符"><a href="#太空船操作符" class="headerlink" title="太空船操作符"></a>太空船操作符</h5><p>太空船操作符用于比较两个表达式。当$a小于、等于或大于$b时它分别返回-1、0或1。 比较的原则是沿用 PHP 的常规比较规则进行的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F; 整数</span><br><span class="line">echo 1 &lt;&#x3D;&gt; 1; &#x2F;&#x2F; 0</span><br><span class="line">echo 1 &lt;&#x3D;&gt; 2; &#x2F;&#x2F; -1</span><br><span class="line">echo 2 &lt;&#x3D;&gt; 1; &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 浮点数</span><br><span class="line">echo 1.5 &lt;&#x3D;&gt; 1.5; &#x2F;&#x2F; 0</span><br><span class="line">echo 1.5 &lt;&#x3D;&gt; 2.5; &#x2F;&#x2F; -1</span><br><span class="line">echo 2.5 &lt;&#x3D;&gt; 1.5; &#x2F;&#x2F; 1</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 字符串</span><br><span class="line">echo &quot;a&quot; &lt;&#x3D;&gt; &quot;a&quot;; &#x2F;&#x2F; 0</span><br><span class="line">echo &quot;a&quot; &lt;&#x3D;&gt; &quot;b&quot;; &#x2F;&#x2F; -1</span><br><span class="line">echo &quot;b&quot; &lt;&#x3D;&gt; &quot;a&quot;; &#x2F;&#x2F; 1</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="通过define-定义常量数组"><a href="#通过define-定义常量数组" class="headerlink" title="通过define()定义常量数组"></a>通过define()定义常量数组</h5><p>Array 类型的常量现在可以通过 define() 来定义。在 PHP5.6 中仅能通过 const 定义。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">define(&#39;ANIMALS&#39;, [</span><br><span class="line">    &#39;dog&#39;,</span><br><span class="line">    &#39;cat&#39;,</span><br><span class="line">    &#39;bird&#39;</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">echo ANIMALS[1]; &#x2F;&#x2F; 输出 &quot;cat&quot;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="Group-use-declarations"><a href="#Group-use-declarations" class="headerlink" title="Group use declarations"></a>Group use declarations</h5><p>从同一 namespace 导入的类、函数和常量现在可以通过单个 use 语句 一次性导入了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; PHP 7 之前的代码</span><br><span class="line">use some\namespace\ClassA;</span><br><span class="line">use some\namespace\ClassB;</span><br><span class="line">use some\namespace\ClassC as C;</span><br><span class="line"></span><br><span class="line">use function some\namespace\fn_a;</span><br><span class="line">use function some\namespace\fn_b;</span><br><span class="line">use function some\namespace\fn_c;</span><br><span class="line"></span><br><span class="line">use const some\namespace\ConstA;</span><br><span class="line">use const some\namespace\ConstB;</span><br><span class="line">use const some\namespace\ConstC;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; PHP 7+ 及更高版本的代码</span><br><span class="line">use some\namespace\&#123;ClassA, ClassB, ClassC as C&#125;;</span><br><span class="line">use function some\namespace\&#123;fn_a, fn_b, fn_c&#125;;</span><br><span class="line">use const some\namespace\&#123;ConstA, ConstB, ConstC&#125;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="Generator-delegation"><a href="#Generator-delegation" class="headerlink" title="Generator delegation"></a>Generator delegation</h5><p>生成器yield from,值得关注.</p>
<p>现在，只需在最外层生成其中使用 yield from， 就可以把一个生成器自动委派给其他的生成器， Traversable 对象或者 array。<br><a href="https://www.php.net/manual/zh/language.generators.syntax.php#control-structures.yield.from" target="_blank" rel="noopener">传送门</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">function gen()</span><br><span class="line">&#123;</span><br><span class="line">    yield 1;</span><br><span class="line">    yield 2;</span><br><span class="line"></span><br><span class="line">    yield from gen2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function gen2()</span><br><span class="line">&#123;</span><br><span class="line">    yield 3;</span><br><span class="line">    yield 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach (gen() as $val)</span><br><span class="line">&#123;</span><br><span class="line">    echo $val, PHP_EOL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="新加的整数除法函数intdiv"><a href="#新加的整数除法函数intdiv" class="headerlink" title="新加的整数除法函数intdiv()"></a>新加的整数除法函数intdiv()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">var_dump(intdiv(10, 3));</span><br><span class="line">?&gt;</span><br><span class="line">以上例程会输出：</span><br><span class="line"></span><br><span class="line">int(3)</span><br></pre></td></tr></table></figure>

<h3 id="值得注意的变更的函数"><a href="#值得注意的变更的函数" class="headerlink" title="值得注意的变更的函数"></a>值得注意的变更的函数</h3><ul>
<li>dirname() 增加了可选的第二个参数, depth, 获取当前目录向上 depth 级父目录的名称</li>
<li>substr() 现在当 start 的值与 string 的长度相同时将返回一个空字符串。</li>
</ul>
<h3 id="值得关注的新的类和接口"><a href="#值得关注的新的类和接口" class="headerlink" title="值得关注的新的类和接口"></a>值得关注的新的类和接口</h3><h5 id="Exception-等级"><a href="#Exception-等级" class="headerlink" title="Exception 等级"></a>Exception 等级</h5><ul>
<li>Throwable</li>
<li>Error</li>
<li>TypeError</li>
<li>ParseError</li>
<li>AssertionError</li>
<li>ArithmeticError</li>
<li>DivisionByZeroError</li>
</ul>
<h3 id="移除的扩展"><a href="#移除的扩展" class="headerlink" title="移除的扩展"></a>移除的扩展</h3><ul>
<li>ereg</li>
<li>mssql</li>
<li>mysql</li>
<li>sybase_ct</li>
</ul>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
</search>
