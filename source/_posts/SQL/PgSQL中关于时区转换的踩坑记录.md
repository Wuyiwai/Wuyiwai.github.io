---
title: PgSQL中关于时区转换的踩坑记录
date: 2020-06-22 15:46:26
updateDate: 2020-06-22 15:46:26
tags: PostgreSQL
categories: PostgreSQL
---
### 当前场景
```
$ show timezone;
- PRC

DDL设计
"create_time" timestamp(6) NOT NULL,

这意味着,Pg数据库设置的默认时区为PRC,东八区.
应用层插入数据库时的create_time不带时区.
```

### 需求
使用应用的用户,每个用户都可以设置自己所处的时区.要求create_time按照用户设置的时区进行转换.

<!--more-->

做法:假设当前用户设置自己所处时区为西五区.

做法: at time zone '+5' 相比于UTC时间增则- 减则+,东八区是-8,则西五区是+5

原始数据:
```
"create_time"
"22/6/2020 15:27:31"
"22/6/2020 15:21:16"
"22/6/2020 14:27:30"
"22/6/2020 14:21:17"
"22/6/2020 13:54:16"
"22/6/2020 13:47:35"
"22/6/2020 12:01:16"
"22/6/2020 11:56:32"
"22/6/2020 11:54:15"
"22/6/2020 11:51:11"
"22/6/2020 11:47:50"
"22/6/2020 11:47:21"
"22/6/2020 11:36:53"
"22/6/2020 11:30:50"
"22/6/2020 11:28:47"
"22/6/2020 11:25:37"
"22/6/2020 11:19:06"
"22/6/2020 11:10:37"
"22/6/2020 11:08:40"
"22/6/2020 11:07:39"
```

第一版sql
```
sql:
SELECT
	create_time at time zone '+5'
FROM
	test
ORDER BY
	create_time DESC 
	LIMIT 20 OFFSET 0;
	
结果: 
"timezone"
"23/6/2020 04:27:31+08:08"
"23/6/2020 04:21:16+08:08"
"23/6/2020 03:27:30+08:08"
"23/6/2020 03:21:17+08:08"
"23/6/2020 02:54:16+08:08"
"23/6/2020 02:47:35+08:08"
"23/6/2020 01:01:16+08:08"
"23/6/2020 00:56:32+08:08"
"23/6/2020 00:54:15+08:08"
"23/6/2020 00:51:11+08:08"
"23/6/2020 00:47:50+08:08"
"23/6/2020 00:47:21+08:08"
"23/6/2020 00:36:53+08:08"
"23/6/2020 00:30:50+08:08"
"23/6/2020 00:28:47+08:08"
"23/6/2020 00:25:37+08:08"
"23/6/2020 00:19:06+08:08"
"23/6/2020 00:10:37+08:08"
"23/6/2020 00:08:40+08:08"
"23/6/2020 00:07:39+08:08"
```
这时发现相比于之前的结果,居然每个结果都+13h了.实际上应该是-13h的.而经过测试,使用`at time zone '-8'`结果则和不使用该语句是一样的.说明在此时的时区转换有些问题.

实际到最后为什么遇到西五区这种偏离结果会出现问题也没有找到靠谱的解释.如果看官找到靠谱的解释可以通过博客主页邮件我进行讨论.

最后在不断查找下找到一种猜想.
在[PostgreSQL 8.2.3 中文文档](https://www.yiibai.com/manual/postgresql/datatype-datetime.html)中有这么一种解释.
```
PostgreSQL 允许你用三种方法指定时区：

完整的时区名。例如 America/New_York 。所有可以识别的时区名在 pg_timezone_names 视图中列出(参见节43.49)。PostgreSQL 使用广泛使用的 zic 时区数据，所以这些时区名在其它软件里也能被轻松的识别。

时区缩写。例如 PST 。这种缩写名通常只是定义了相对于 UTC 的偏移量，而前一种完整的时区名可能还隐含着一组夏时制转换规则。所有可以识别的时区缩写在 pg_timezone_abbrevs 视图中列出(参见节43.48)。你不能使用时区缩写来设置 timezone 配置参数，但是你可以在日期/时间输入值中结合 AT TIME ZONE 操作符使用时区缩写。

除完整的时区名及其缩写之外，PostgreSQL 还接受 POSIX 风格的 STDoffset 或 STDoffsetDST 格式的时区，其中的 STD 是时区缩写、offset 是一个相对于 UTC 的小时偏移量、DST 是一个可选的夏时制时区缩写(假定相对于给定的偏移量提前一小时)。例如，如果 EST5EDT 不是一个已识别的时区名，那么它将等同于美国东部时间，如果存在夏时制时区，那么它将按照美国的时区规则使用，因此这个特性在北美州之外没什么用处。需要提醒的是这个特性会导致悄悄的接受不合理的输入，因为它不对时区缩写的合理性做检查。例如，SET TIMEZONE TO FOOBAR0 不会报错，而是使系统使用 GMT 。

完整的时区名与时区缩写在理论与实践之间存在差异：时区缩写总是代表一个相对于 UTC 的固定偏移量，然而大多数完整的时区名隐含着一个本地夏令时规则，因此就有可能有两个相对于 UTC 的不同偏移量。
```
在第一版sql中没有使用显示指定timestamp.所以可能在偏离量上有两种不同的偏移量.
所以我尝试了使用`::timestamp`指定时区再进行时区偏移转换.

所以第二版sql如下:
```
sql:
SELECT
	create_time::timestamp with time zone at time zone '+5'
FROM
	test
ORDER BY
	create_time DESC 
	LIMIT 20 OFFSET 0;
```
结果如下: 
```
"timezone"
"22/6/2020 02:27:31"
"22/6/2020 02:21:16"
"22/6/2020 01:27:30"
"22/6/2020 01:21:17"
"22/6/2020 00:54:16"
"22/6/2020 00:47:35"
"21/6/2020 23:01:16"
"21/6/2020 22:56:32"
"21/6/2020 22:54:15"
"21/6/2020 22:51:11"
"21/6/2020 22:47:50"
"21/6/2020 22:47:21"
"21/6/2020 22:36:53"
"21/6/2020 22:30:50"
"21/6/2020 22:28:47"
"21/6/2020 22:25:37"
"21/6/2020 22:19:06"
"21/6/2020 22:10:37"
"21/6/2020 22:08:40"
```
结果是正确的.经测试,这时使用+8偏移量也正确.